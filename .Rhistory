clim_fc = climatology_threshold_exceedence(dt_obs,
obs_col = 'prec',
thresholds = unique(dt[,rthr]),
by_cols = c('month','lon','lat'))
print(clim_fc)
setnames(clim_fc,c('pexcd','threshold'),c('clim','rthr'))
clim_fc
dt = merge(dt,clim_fc[year == 2021,.(lon,lat,month,rthr)],by = c('lon','lat','month','rthr'))
print(dt)
dt[,unique(rthr)]
clim_fc[year == 2021,.(lon,lat,month,rthr)]
clim_dt = climatology_ens_forecast(obs_dt,by_cols = by_cols)
ret_dt = data.table()
thr = 200
thresholds
thr_dt = clim_dt[,.(pexcd = mean(get(obs_col) >= thr)),by = c(by_cols,'year')]
thr_dt
thr_dt[,threshold := thr]
thr_dt
ret_dt = rbindlist(list(ret_dt,thr_dt))
ret_dt
thr = 300
thr_dt = clim_dt[,.(pexcd = mean(get(obs_col) >= thr)),by = c(by_cols,'year')]
thr_dt
thr_dt[,threshold := thr]
thr_dt
ret_dt
ret_dt = rbindlist(list(ret_dt,thr_dt))
ret_dt
climatology_threshold_exceedence = function(obs_dt,
obs_col = 'prec',
by_cols = intersect(c('lon','lat','month','season'),names(obs_dt)),
thresholds = c(200,300,350,400))
{
clim_dt = climatology_ens_forecast(obs_dt,by_cols = by_cols)
ret_dt = data.table()
for(thr in thresholds)
{
thr_dt = clim_dt[,.(pexcd = mean(get(obs_col) >= thr)),by = c(by_cols,'year')]
thr_dt[,threshold := thr]
ret_dt = rbindlist(list(ret_dt,thr_dt))
}
return(ret_dt)
}
clim_fc = climatology_threshold_exceedence(dt_obs,
obs_col = 'prec',
thresholds = unique(dt[,rthr]),
by_cols = c('month','lon','lat'))
dt = netcdf_to_dt(paste0(data_dir,fn))
dt
modelnames = c('GEM-NEMO','CanCM4i','NASA-GEOSS2S','GFDL-SPEAR','COLA-RSMAS-CCSM4','NCEP-CFSv2','ECMWF','Meteo_France','UKMO')
thresholds = c(200,300,350,400)
dt[,model := modelnames[model + 1]][,rthr := thresholds[rthr + 1]]
dt[,month :=lead + 2][,lead:=NULL]
print(clim_fc)
clim_fc = climatology_threshold_exceedence(dt_obs,
obs_col = 'prec',
thresholds = unique(dt[,rthr]),
by_cols = c('month','lon','lat'))
print(clim_fc)
setnames(clim_fc,c('pexcd','threshold'),c('clim','rthr'))
dt = merge(dt,clim_fc[year == 2021,.(lon,lat,month,rthr)],by = c('lon','lat','month','rthr'))
dt
clim_fc
clim_fc
dt = merge(dt,clim_fc[year == 2021,],by = c('lon','lat','month','rthr'))
dt
dt_obs
dt
dt = merge(dt,dt_obs[year == 2021],by = c('lon','lat','month','year'))
dt
fc_dt = dt
fc_col = 'pexcd'
clim_col = 'clim'
obs_col = 'prec'
by_cols = c('month','lon','lat','model')
ES_dt = ES_dt(fc_dt = fc_dt,
fc_col = fc_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
ES_dt = function(fc_dt,fc_col,threshold_col,
obs_col = 'obs',
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)),
along_cols = c('year'))
{
if(is.logical(fc_dt[,get(obs_col)]))
{
ES_dt = fc_dt_new[,.(ES = get(fc_col)^2 - 2*get(fc_col) * get(obs_col)),by = c(by_cols,threshold_col)]# the by-arguments are for keeping these columns only
}
if(!is.logical(fc_dt[,get(obs_col)]))
{
ES_dt = fc_dt_new[,.(ES = get(fc_col)^2 - 2*get(fc_col) * (get(obs_col) > get(threshold_col))),by = c(by_cols,threshold_col)]
}
return(ES_dt)
}
ES_dt = ES_dt(fc_dt = fc_dt,
fc_col = fc_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
climES_dt = ES_dt(fc_dt = fc_dt,
fc_col = clim_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
ES_dt = function(fc_dt,fc_col,threshold_col,
obs_col = 'obs',
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)),
along_cols = c('year'))
{
if(is.logical(fc_dt[,get(obs_col)]))
{
ES_dt = fc_dt_new[,.(ES = get(fc_col)^2 - 2*get(fc_col) * get(obs_col)),by = c(by_cols,threshold_col)]# the by-arguments are for keeping these columns only
}
if(!is.logical(fc_dt[,get(obs_col)]))
{
ES_dt = fc_dt_new[,.(ES = get(fc_col)^2 - 2*get(fc_col) * (get(obs_col) > get(threshold_col))),by = c(by_cols,threshold_col)]
}
return(ES_dt)
}
es_dt = ES_dt(fc_dt = fc_dt,
fc_col = fc_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
clim_es_dt = ES_dt(fc_dt = fc_dt,
fc_col = clim_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
fc_dt
ES_dt = function(fc_dt,fc_col,threshold_col,
obs_col = 'obs',
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)),
along_cols = c('year'))
{
if(is.logical(fc_dt[,get(obs_col)]))
{
ES_dt = fc_dt[,.(ES = get(fc_col)^2 - 2*get(fc_col) * get(obs_col)),by = c(by_cols,threshold_col)]# the by-arguments are for keeping these columns only
}
if(!is.logical(fc_dt[,get(obs_col)]))
{
ES_dt = fc_dt[,.(ES = get(fc_col)^2 - 2*get(fc_col) * (get(obs_col) > get(threshold_col))),by = c(by_cols,threshold_col)]
}
return(ES_dt)
}
es_dt = ES_dt(fc_dt = fc_dt,
fc_col = fc_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
clim_es_dt = ES_dt(fc_dt = fc_dt,
fc_col = clim_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
es_dt
clim_es_dt
setnames(clim_es_dt,'ES','clim_ES')
es_dt = merge(es_dt,clim_es_dt,by = intersect(names(es_dt),names(clim_es_dt)))
es_dt
es_dt[,ESS := (clim_ES - ES)/(clim_Es + 1)] # perfect ES = -1
es_dt[,ESS := (clim_ES - ES)/(clim_ES + 1)] # perfect ES = -1
es_dt
plot_list = list()
for(mod in unique(ES_dt[,model]))
{
plot_list = c(plot_list,list(ggplot_dt(es_dt[model == mod& month == 3 & rthr == 300],'ESS',mn = mod, high = 'red',midpoint = 0,rr= c(-1,1))))
}
plot_list = list()
for(mod in unique(es_dt[,model]))
{
plot_list = c(plot_list,list(ggplot_dt(es_dt[model == mod& month == 3 & rthr == 300],'ESS',mn = mod, high = 'red',midpoint = 0,rr= c(-1,1))))
}
ggpubr::ggarrange(plotlist = plot_list,ncol = 3,nrow = 3)
es_dt
clim_es_dt
fc_dt
ES_dt = function(fc_dt,fc_col,threshold_col,
obs_col = 'obs',
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)),
along_cols = c('year'))
{
if(is.logical(fc_dt[,get(obs_col)]))
{
ES_dt = fc_dt[,.(ES = (get(fc_col)-get(obs_col))^2),by = c(by_cols,threshold_col)]# the by-arguments are for keeping these columns only
}
if(!is.logical(fc_dt[,get(obs_col)]))
{
ES_dt = fc_dt[,.(ES = (get(fc_col) - (get(obs_col) > get(threshold_col)))^2),by = c(by_cols,threshold_col)]
}
return(ES_dt)
}
climatology_threshold_exceedence = function(obs_dt,
obs_col = 'prec',
by_cols = intersect(c('lon','lat','month','season'),names(obs_dt)),
thresholds = c(200,300,350,400))
{
clim_dt = climatology_ens_forecast(obs_dt,by_cols = by_cols)
ret_dt = data.table()
for(thr in thresholds)
{
thr_dt = clim_dt[,.(pexcd = mean(get(obs_col) > thr)),by = c(by_cols,'year')]
thr_dt[,threshold := thr]
ret_dt = rbindlist(list(ret_dt,thr_dt))
}
return(ret_dt)
}
ESS_dt = function(fc_dt,
fc_col,
clim_col = 'clim',
threshold_col,
obs_col = 'obs',
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)))
{
es_dt = ES_dt(fc_dt = fc_dt,
fc_col = fc_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
clim_es_dt = ES_dt(fc_dt = fc_dt,
fc_col = clim_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
setnames(clim_es_dt,'ES','clim_ES')
es_dt = merge(es_dt,clim_es_dt,by = intersect(names(es_dt),names(clim_es_dt)))
es_dt[,ESS := (clim_ES - ES)/clim_ES ] # perfect score = 1{y > threshold}
return(es_dt)
}
ESS_dt = ESS_dt(dt,'pexcd','rthr',obs_col = 'prec',by_cols = c('model','month','lon','lat'))
print(dt)
dt[,pexcd := pexcd/100]
ESS_dt = ESS_dt(dt,'pexcd','rthr',obs_col = 'prec',by_cols = c('model','month','lon','lat'))
ESS_dt = ESS_dt(dt,fc_col = 'pexcd',threshold_col = 'rthr',obs_col = 'prec',by_cols = c('model','month','lon','lat'))
ESS_dt
ESS_dt = function(fc_dt,
fc_col,
clim_col = 'clim',
threshold_col,
obs_col = 'obs',
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)))
{
es_dt = ES_dt(fc_dt = fc_dt,
fc_col = fc_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
clim_es_dt = ES_dt(fc_dt = fc_dt,
fc_col = clim_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
setnames(clim_es_dt,'ES','clim_ES')
es_dt = merge(es_dt,clim_es_dt,by = intersect(names(es_dt),names(clim_es_dt)))
es_dt[,ESS := (clim_ES - ES)/clim_ES ]
#deal with divisions by 0:
es_dt[clim_ES == 0 & ES == 0, ESS := 0] # when both are perfect, skill score should be 0
es_dt[clim_ES == 0 & ES > 0, ESS := min(min(ESS,na.rm = T), -1)] # set to something negative when climatology predicts perfectly and prediction does not (should actually -Inf, but that's bad for plotting).
return(es_dt)
}
ess_dt = ESS_dt(dt,fc_col = 'pexcd',threshold_col = 'rthr',obs_col = 'prec',by_cols = c('model','month','lon','lat'))
plot_list = list()
for(mod in unique(ess_dt[,model]))
{
plot_list = c(plot_list,list(ggplot_dt(ess_dt[model == mod& month == 3 & rthr == 300],'ESS',mn = mod, high = 'red',midpoint = 0,rr= c(-1,1))))
}
ggpubr::ggarrange(plotlist = plot_list,ncol = 3,nrow = 3)
es_dt
ggplot_dt(es_dt[month == 2 & model == model[1] & rthr = rthr[1]],'ES')
ggplot_dt(es_dt[month == 2 & model == model[1] & rthr == rthr[1]],'ES')
dt
ess_dt = ESS_dt(dt,fc_col = 'pexcd',threshold_col = 'rthr',obs_col = 'prec',by_cols = c('model','month','lon','lat'))
ggplot_dt(ess_dt[month == 2 & model == model[1] & rthr == rthr[1]],'ES')
ess_dt
ggplot_dt(ess_dt[month == 2 & model == model[1] & rthr == rthr[1]],'clim_ES')
ggplot_dt(ess_dt[month == 2 & model == model[1] & rthr == rthr[1]],'ESS')
ESS_dt = function(fc_dt,
fc_col,
clim_col = 'clim',
threshold_col,
obs_col = 'obs',
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)))
{
es_dt = ES_dt(fc_dt = fc_dt,
fc_col = fc_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
clim_es_dt = ES_dt(fc_dt = fc_dt,
fc_col = clim_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
setnames(clim_es_dt,'ES','clim_ES')
es_dt = merge(es_dt,clim_es_dt,by = intersect(names(es_dt),names(clim_es_dt)))
es_dt[,ESS := (clim_ES - ES)/clim_ES ]
#deal with divisions by 0:
es_dt[clim_ES == 0 & ES == 0, ESS := 0] # when both are perfect, skill score should be 0
es_dt[clim_ES == 0 & ES > 0, ESS := max(min(min(ESS,na.rm = T), -1),-10)] # set to something negative (between -1 and -10), when climatology predicts perfectly and the forecast does not
#(should actually -Inf, but that's bad for plotting).
return(es_dt)
}
ess_dt = ESS_dt(dt,fc_col = 'pexcd',threshold_col = 'rthr',obs_col = 'prec',by_cols = c('model','month','lon','lat'))
plot_list = list()
for(mod in unique(ess_dt[,model]))
{
plot_list = c(plot_list,list(ggplot_dt(ess_dt[model == mod& month == 3 & rthr == 300],'ESS',mn = mod, high = 'red',midpoint = 0,rr= c(-1,1))))
}
ggpubr::ggarrange(plotlist = plot_list,ncol = 3,nrow = 3)
plot_list = list()
for(mod in unique(ess_dt[,model]))
{
plot_list = c(plot_list,list(ggplot_dt(ess_dt[model == mod& month == 3 & rthr == 400],'ESS',mn = mod, high = 'red',midpoint = 0,rr= c(-1,1))))
}
ggpubr::ggarrange(plotlist = plot_list,ncol = 3,nrow = 3)
plot_list = list()
for(mod in unique(ess_dt[,model]))
{
plot_list = c(plot_list,list(ggplot_dt(ess_dt[model == mod& month == 3 & rthr == 200],'ESS',mn = mod, high = 'red',midpoint = 0,rr= c(-1,1))))
}
ggpubr::ggarrange(plotlist = plot_list,ncol = 3,nrow = 3)
fns = list.files(data_dir,pattern = '*.nc')
fn = 'PrecRegPeXcd_3monthSeasonal.nc'
data_dir = '/nr/project/stat/CONFER/Data/validation/example_data/202102/'
dt = netcdf_to_dt(paste0(data_dir,fn))
dt
modelnames = c('GEM-NEMO','CanCM4i','NASA-GEOSS2S','GFDL-SPEAR','COLA-RSMAS-CCSM4','NCEP-CFSv2','ECMWF','Meteo_France','UKMO')
thresholds = c(200,300,350,400)
dt[,model := modelnames[model + 1]][,rthr := thresholds[rthr + 1]]
dt[,month :=lead + 2][,lead:=NULL]
dt_obs = PostProcessing::load_chirps()[,index_coarse:= NULL]
dt_obs = dt_obs[ month >=2 & month <= 5]
dt_obs[,prec:=30*prec]
#' Calculate exceedence Brier score
#'
#' @param fc_dt Data table containing the predictions.
#' @param fc_col column name of the prediction. Contains predicted probabilities of exceedence
#' @param threshold_col which column contains the exceedence threshold?
#' @param obs_col column name of the observations, that is
#' @param by_cols column names of grouping variables, all of which need to be columns in fc_dt.
#' Default is to group by all instances of month, season, lon, lat, system and lead_time that are columns in fc_dt.
#' @export
BS_ex_dt = function(fc_dt,fc_col,threshold_col,
obs_col = 'obs',
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)),
along_cols = c('year'))
{
if(range(fc_dt[,get(fc_col)],na.rm = T)[2] > 1) stop('your predictions should be values between 0 and 1.')
if(is.logical(fc_dt[,get(obs_col)]))
{
Score_dt = fc_dt[,.(BS_ex = (get(fc_col)-get(obs_col))^2),by = c(by_cols,threshold_col)]# the by-arguments are for keeping these columns only
}
if(!is.logical(fc_dt[,get(obs_col)]))
{
Score_dt = fc_dt[,.(BS_ex = (get(fc_col) - (get(obs_col) > get(threshold_col)))^2),by = c(by_cols,threshold_col)]
}
return(Score_dt)
}
climatology_threshold_exceedence = function(obs_dt,
obs_col = 'prec',
by_cols = intersect(c('lon','lat','month','season'),names(obs_dt)),
thresholds = c(200,300,350,400))
{
clim_dt = climatology_ens_forecast(obs_dt,by_cols = by_cols)
ret_dt = data.table()
for(thr in thresholds)
{
thr_dt = clim_dt[,.(pexcd = mean(get(obs_col) > thr)),by = c(by_cols,'year')]
thr_dt[,threshold := thr]
ret_dt = rbindlist(list(ret_dt,thr_dt))
}
return(ret_dt)
}
#' Calculate exceedence Brier skill score
#'
#' @param fc_dt Data table containing the predictions.
#' @param fc_col column name of the prediction. Contains predicted probabilities of exceedence
#' @param threshold_col which column contains the exceedence threshold?
#' @param obs_col column name of the observations, that is
#' @param by_cols column names of grouping variables, all of which need to be columns in fc_dt.
#' Default is to group by all instances of month, season, lon, lat, system and lead_time that are columns in fc_dt.
#' @export
BSS_ex_dt = function(fc_dt,
fc_col,
clim_col = 'clim',
threshold_col,
obs_col = 'obs',
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)))
{
es_dt = BS_ex_dt(fc_dt = fc_dt,
fc_col = fc_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
clim_es_dt = BS_ex_dt(fc_dt = fc_dt,
fc_col = clim_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
setnames(clim_es_dt,'BS_ex','clim_BS_ex')
score_dt = merge(es_dt,clim_es_dt,by = intersect(names(es_dt),names(clim_es_dt)))
score_dt[,BSS_ex := (clim_BS_ex - BS_ex)/clim_BS_ex ]
#deal with divisions by 0:
es_dt[clim_BS_ex == 0 & BS_ex == 0, BSS_ex := 0] # when both are perfect, skill score should be 0
es_dt[clim_BS_ex == 0 & BS_ex > 0, BSS_ex := min(min(BSS_ex,na.rm = T), -1)] # set to something negative (capped at -1), when climatology predicts perfectly and the forecast does not
#(should actually -Inf, but that's bad for plotting).
return(es_dt)
}
clim_fc = climatology_threshold_exceedence(dt_obs,
obs_col = 'prec',
thresholds = unique(dt[,rthr]),
by_cols = c('month','lon','lat'))
print(clim_fc)
setnames(clim_fc,c('pexcd','threshold'),c('clim','rthr'))
dt = merge(dt,clim_fc[year == 2021,],by = c('lon','lat','month','rthr'))
dt = merge(dt,dt_obs[year == 2021],by = c('lon','lat','month','year'))
print(dt)
ggplot_dt(dt[month == 2 & model == 'GEM-NEMO' & rthr == 200],'pexcd')
ggplot_dt(dt[month == 2 & model == 'GEM-NEMO' & rthr == 200],'prec')
dt[,pexcd := pexcd/100]
bss_dt = BSS_ex_dt(dt,fc_col = 'pexcd',threshold_col = 'rthr',obs_col = 'prec',by_cols = c('model','month','lon','lat'))
BS_ex_dt = BS_ex_dt(dt,'pexcd','rthr',obs_col = 'prec',by_cols = c('model','month','lon','lat'))
plot_list = list()
for(mod in unique(bss_dt[,model]))
{
plot_list = c(plot_list,list(ggplot_dt(bss_dt[model == mod& month == 3 & rthr == 200],'BSS_ex',mn = mod, high = 'red',midpoint = 0,rr= c(-1,1))))
}
fc_dt = dt
fc_col = 'pexcd'
threshold_col = 'rthr'
obs_col = 'prec'
by_cols = c('model','month','lon','lat')
BS_dt = BS_ex_dt(fc_dt = fc_dt,
fc_col = fc_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
BS_ex_dt = function(fc_dt,fc_col,threshold_col,
obs_col = 'obs',
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)),
along_cols = c('year'))
{
if(range(fc_dt[,get(fc_col)],na.rm = T)[2] > 1) stop('your predictions should be values between 0 and 1.')
if(is.logical(fc_dt[,get(obs_col)]))
{
Score_dt = fc_dt[,.(BS_ex = (get(fc_col)-get(obs_col))^2),by = c(by_cols,threshold_col)]# the by-arguments are for keeping these columns only
}
if(!is.logical(fc_dt[,get(obs_col)]))
{
Score_dt = fc_dt[,.(BS_ex = (get(fc_col) - (get(obs_col) > get(threshold_col)))^2),by = c(by_cols,threshold_col)]
}
return(Score_dt)
}
BS_dt = BS_ex_dt(fc_dt = fc_dt,
fc_col = fc_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
clim_es_dt = BS_ex_dt(fc_dt = fc_dt,
fc_col = clim_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
setnames(clim_es_dt,'BS_ex','clim_BS_ex')
score_dt = merge(es_dt,clim_es_dt,by = intersect(names(es_dt),names(clim_es_dt)))
score_dt[,BSS_ex := (clim_BS_ex - BS_ex)/clim_BS_ex ]
score_dt
score_dt = merge(BS_dt,clim_es_dt,by = intersect(names(es_dt),names(clim_es_dt)))
score_dt[,BSS_ex := (clim_BS_ex - BS_ex)/clim_BS_ex ]
#deal with divisions by 0:
es_dt[clim_BS_ex == 0 & BS_ex == 0, BSS_ex := 0] # when both are perfect, skill score should be 0
#deal with divisions by 0:
score_dt[clim_BS_ex == 0 & BS_ex == 0, BSS_ex := 0] # when both are perfect, skill score should be 0
score_dt[clim_BS_ex == 0 & BS_ex > 0, BSS_ex := min(min(BSS_ex,na.rm = T), -1)] # set to something negative (capped at -1), when climatology predicts perfectly and the forecast does not
BSS_ex_dt = function(fc_dt,
fc_col,
clim_col = 'clim',
threshold_col,
obs_col = 'obs',
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)))
{
BS_dt = BS_ex_dt(fc_dt = fc_dt,
fc_col = fc_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
clim_es_dt = BS_ex_dt(fc_dt = fc_dt,
fc_col = clim_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
setnames(clim_es_dt,'BS_ex','clim_BS_ex')
score_dt = merge(BS_dt,clim_es_dt,by = intersect(names(es_dt),names(clim_es_dt)))
score_dt[,BSS_ex := (clim_BS_ex - BS_ex)/clim_BS_ex ]
#deal with divisions by 0:
score_dt[clim_BS_ex == 0 & BS_ex == 0, BSS_ex := 0] # when both are perfect, skill score should be 0
score_dt[clim_BS_ex == 0 & BS_ex > 0, BSS_ex := min(min(BSS_ex,na.rm = T), -1)] # set to something negative (capped at -1), when climatology predicts perfectly and the forecast does not
#(should actually -Inf, but that's bad for plotting).
return(score_dt)
}
bss_dt = BSS_ex_dt(dt,fc_col = 'pexcd',threshold_col = 'rthr',obs_col = 'prec',by_cols = c('model','month','lon','lat'))
plot_list = list()
for(mod in unique(bss_dt[,model]))
{
plot_list = c(plot_list,list(ggplot_dt(bss_dt[model == mod& month == 3 & rthr == 200],'BSS_ex',mn = mod, high = 'red',midpoint = 0,rr= c(-1,1))))
}
ggpubr::ggarrange(plotlist = plot_list,ncol = 3,nrow = 3)
bss_dt
devtools::document()
q()
