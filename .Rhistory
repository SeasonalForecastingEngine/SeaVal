ggproto
ggplot_dt = function(dt,
data_col = colnames(dt)[3],
mn = NULL, discrete_cs = FALSE,
rr = NULL,low = "blue", mid = "white", high = "red",name = data_col,midpoint = NULL,...,
binwidth = NULL,
colorscale = NULL, tol = 0)
{
####### transform data #######
# if you have spatio-temporal data, plot only only the first time-slice of it (convenient for diagnostics).
time_cols = intersect(names(dt),c('month','year','day','date','season'))
dt_sm = dt[,.SD,.SDcols = c('lon','lat',data_col,time_cols)][!is.na(get(data_col))]
if(length(time_cols)>0)
{
tc1 = dt_sm[1,.SD,.SDcols = time_cols]
dt_sm = merge(dt_sm,tc1,by = time_cols)
}
#### get map: ####
world_map <- ggplot2::map_data(map = 'world',resolution = 0)
# better maps are available with the rnaturalearth package and can be plotted using geom_sf.
# However, this approach requires gdal, so it's not exactly easily accessible.
#### fix range and set values outside of range to the range border ####
if(is.null(rr))
{
rr = dt_sm[,range(get(data_col))]
}
# set midpoint and color scale
if(is.null(midpoint))
{
midpoint = rr[1] + (rr[2]-rr[1])/2
}
if(is.null(colorscale))
{
if(!discrete_cs)
{
colorscale = scale_fill_gradient2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,...)
}
if(discrete_cs)
{
if(!is.null(bin_size))
{
nbinapprox = floor((rr[2] - rr[1])/bin_size)
bins1 = bin_size*(1/2 + (0:nbinapprox)) + midpoint
bins2 = -bin_size*(1/2 + (0:nbinapprox)) + midpoint
bins=  sort(unique(c(bins2,bins1)))
bins = round(bins[bins %between% rr],2)
colorscale = scale_fill_steps2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,breaks = bins,...)
}
colorscale = scale_fill_steps2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,...)
}
}
lower_indices = dt_sm[,which(get(data_col) < rr[1])]
upper_indices = dt_sm[,which(get(data_col) > rr[2])]
dt_sm[lower_indices,(data_col) := rr[1]]
dt_sm[upper_indices,(data_col) := rr[2]]
### setup for plotting ###
lats = sort(unique(dt_sm[,lat]))
lons = sort(unique(dt_sm[,lon]))
dt_sm = dt_sm[!is.na(get(data_col))]
lon_dist = lons[2] - lons[1]
lat_dist = lats[2] - lats[1]
lon_range = range(lons) + c(-lon_dist/2-tol,lon_dist/2+tol)
lat_range = range(lats) + c(-lat_dist/2-tol,lat_dist/2+tol)
### plotting ###
pp = ggplot(data = dt_sm) +
geom_rect(xmin = min(lons) - lon_dist-tol,                             # add gray rectangle in the background, such that missing values appear gray
xmax = max(lons) + lon_dist+tol,
ymin = min(lats) - lat_dist-tol,
ymax = max(lats) + lat_dist+tol,fill = 'gray') +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = lon_range,ylim = lat_range,expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank())
if(!is.null(mn)) pp = pp + ggtitle(mn)                               # add title, if given
return(pp)
}
pp = ggplot_dt(chirps_monthly[month == 10 & year == 2020], 'ano',
mn = 'October 2020 rainfall anomaly',
discrete_cs = TRUE,binwidth = 1,
low = 'red', mid = 'white', high = 'darkgreen',
midpoint = 0,
name = 'mm/day') +
geom_point(data = loc,mapping = aes(x = lon,y = lat)) +
geom_text(data = loc,mapping = aes(x = lon,y = lat,label = name),vjust = 1.5)
source('~/pkg/ForecastTools/R/plotting.R')
pp = ggplot_dt(chirps_monthly[month == 10 & year == 2020], 'ano',
mn = 'October 2020 rainfall anomaly',
discrete_cs = TRUE,binwidth = 1,
low = 'red', mid = 'white', high = 'darkgreen',
midpoint = 0,
name = 'mm/day') +
geom_point(data = loc,mapping = aes(x = lon,y = lat)) +
geom_text(data = loc,mapping = aes(x = lon,y = lat,label = name),vjust = 1.5)
source('~/pkg/ForecastTools/R/plotting.R')
pp = ggplot_dt(chirps_monthly[month == 10 & year == 2020], 'ano',
mn = 'October 2020 rainfall anomaly',
discrete_cs = TRUE,binwidth = 1,
low = 'red', mid = 'white', high = 'darkgreen',
midpoint = 0,
name = 'mm/day') +
geom_point(data = loc,mapping = aes(x = lon,y = lat)) +
geom_text(data = loc,mapping = aes(x = lon,y = lat,label = name),vjust = 1.5)
pp
dt = chirps_monthly[month == 10 & year == 2020]
data_col = colnames(dt)[3]
mn = NULL
discrete_cs = T
binwidth = 1
low = 'red'
mid = 'white'
high = 'darkgreen'
midpoint = 0
name = 'mm/day'
time_cols = intersect(names(dt),c('month','year','day','date','season'))
dt_sm = dt[,.SD,.SDcols = c('lon','lat',data_col,time_cols)][!is.na(get(data_col))]
if(length(time_cols)>0)
{
tc1 = dt_sm[1,.SD,.SDcols = time_cols]
dt_sm = merge(dt_sm,tc1,by = time_cols)
}
world_map <- ggplot2::map_data(map = 'world',resolution = 0)
if(is.null(rr))
{
rr = dt_sm[,range(get(data_col))]
}
rr = NULL
if(is.null(rr))
{
rr = dt_sm[,range(get(data_col))]
}
if(is.null(midpoint))
{
midpoint = rr[1] + (rr[2]-rr[1])/2
}
is.null(colorscale)
!discrete_cs
!is.null(binwidth)
nbinapprox = floor((rr[2] - rr[1])/binwidth)
nbinapprox
bins1 = binwidth*(1/2 + (0:nbinapprox)) + midpoint
bins2 = -binwidth*(1/2 + (0:nbinapprox)) + midpoint
bins1
bins2
bins=  sort(unique(c(bins2,bins1)))
bins
bins = round(bins[bins %between% rr],2)
bins
rr
dt_sm
dt = chirps_monthly[month == 10 & year == 2020]
dt
data_col = 'ano'
rr = NULL
time_cols = intersect(names(dt),c('month','year','day','date','season'))
dt_sm = dt[,.SD,.SDcols = c('lon','lat',data_col,time_cols)][!is.na(get(data_col))]
if(length(time_cols)>0)
{
tc1 = dt_sm[1,.SD,.SDcols = time_cols]
dt_sm = merge(dt_sm,tc1,by = time_cols)
}
world_map <- ggplot2::map_data(map = 'world',resolution = 0)
if(is.null(rr))
{
rr = dt_sm[,range(get(data_col))]
}
if(is.null(midpoint))
{
midpoint = rr[1] + (rr[2]-rr[1])/2
}
midpoint
nbinapprox = floor((rr[2] - rr[1])/binwidth)
bins1 = binwidth*(1/2 + (0:nbinapprox)) + midpoint
bins2 = -binwidth*(1/2 + (0:nbinapprox)) + midpoint
bins=  sort(unique(c(bins2,bins1)))
bins = round(bins[bins %between% rr],2)
bins
colorscale = scale_fill_steps2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,breaks = bins)
lower_indices = dt_sm[,which(get(data_col) < rr[1])]
upper_indices = dt_sm[,which(get(data_col) > rr[2])]
dt_sm[lower_indices,(data_col) := rr[1]]
dt_sm[upper_indices,(data_col) := rr[2]]
lats = sort(unique(dt_sm[,lat]))
lons = sort(unique(dt_sm[,lon]))
dt_sm = dt_sm[!is.na(get(data_col))]
lon_dist = lons[2] - lons[1]
lat_dist = lats[2] - lats[1]
lon_range = range(lons) + c(-lon_dist/2-tol,lon_dist/2+tol)
lat_range = range(lats) + c(-lat_dist/2-tol,lat_dist/2+tol)
### plotting ###
pp = ggplot(data = dt_sm) +
geom_rect(xmin = min(lons) - lon_dist-tol,                             # add gray rectangle in the background, such that missing values appear gray
xmax = max(lons) + lon_dist+tol,
ymin = min(lats) - lat_dist-tol,
ymax = max(lats) + lat_dist+tol,fill = 'gray') +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = lon_range,ylim = lat_range,expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank())
tol = 0
### plotting ###
pp = ggplot(data = dt_sm) +
geom_rect(xmin = min(lons) - lon_dist-tol,                             # add gray rectangle in the background, such that missing values appear gray
xmax = max(lons) + lon_dist+tol,
ymin = min(lats) - lat_dist-tol,
ymax = max(lats) + lat_dist+tol,fill = 'gray') +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = lon_range,ylim = lat_range,expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank())
lon_range = range(lons) + c(-lon_dist/2-tol,lon_dist/2+tol)
lat_range = range(lats) + c(-lat_dist/2-tol,lat_dist/2+tol)
### plotting ###
pp = ggplot(data = dt_sm) +
geom_rect(xmin = min(lons) - lon_dist-tol,                             # add gray rectangle in the background, such that missing values appear gray
xmax = max(lons) + lon_dist+tol,
ymin = min(lats) - lat_dist-tol,
ymax = max(lats) + lat_dist+tol,fill = 'gray') +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = lon_range,ylim = lat_range,expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank())
pp
source('~/pkg/ForecastTools/R/plotting.R')
pp = ggplot_dt(chirps_monthly[month == 10 & year == 2020], 'ano',
mn = 'October 2020 rainfall anomaly',
low = 'red', mid = 'white', high = 'darkgreen',
midpoint = 0,discrete_scale = TRUE,binwidth = 2,
name = 'mm/day') +
geom_point(data = loc,mapping = aes(x = lon,y = lat)) +
geom_text(data = loc,mapping = aes(x = lon,y = lat,label = name),vjust = 1.5)
pp = ggplot_dt(chirps_monthly[month == 10 & year == 2020], 'ano',
mn = 'October 2020 rainfall anomaly',
low = 'red', mid = 'white', high = 'darkgreen',
midpoint = 0,discrete_sc = TRUE,binwidth = 2,
name = 'mm/day') +
geom_point(data = loc,mapping = aes(x = lon,y = lat)) +
geom_text(data = loc,mapping = aes(x = lon,y = lat,label = name),vjust = 1.5)
pp = ggplot_dt(chirps_monthly[month == 10 & year == 2020], 'ano',
mn = 'October 2020 rainfall anomaly',
low = 'red', mid = 'white', high = 'darkgreen',
midpoint = 0,discrete_cs = TRUE,binwidth = 2,
name = 'mm/day') +
geom_point(data = loc,mapping = aes(x = lon,y = lat)) +
geom_text(data = loc,mapping = aes(x = lon,y = lat,label = name),vjust = 1.5)
pp
dt = chirps_monthly[month == 10 & year == 2020]
data_col = 'ano'
mn = 'October 2020 rainfall anomaly'
discrete_cs = TRUE
binwidth = 2
low = 'red'
mid = 'white'
high = 'darkgreen'
midpoint = 0
name = 'mm/day'
rr = NULL
colorscale
colorscale = NULL
tol = 0
time_cols = intersect(names(dt),c('month','year','day','date','season'))
dt_sm = dt[,.SD,.SDcols = c('lon','lat',data_col,time_cols)][!is.na(get(data_col))]
if(length(time_cols)>0)
{
tc1 = dt_sm[1,.SD,.SDcols = time_cols]
dt_sm = merge(dt_sm,tc1,by = time_cols)
}
world_map <- ggplot2::map_data(map = 'world',resolution = 0)
if(is.null(rr))
{
rr = dt_sm[,range(get(data_col))]
}
if(is.null(midpoint))
{
midpoint = rr[1] + (rr[2]-rr[1])/2
}
discrete_cs
!is.null(binwidth)
nbinapprox = floor((rr[2] - rr[1])/binwidth)
bins1 = binwidth*(1/2 + (0:nbinapprox)) + midpoint
bins2 = -binwidth*(1/2 + (0:nbinapprox)) + midpoint
bins=  sort(unique(c(bins2,bins1)))
bins = round(bins[bins %between% rr],2)
colorscale = scale_fill_steps2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,breaks = bins)
lower_indices = dt_sm[,which(get(data_col) < rr[1])]
upper_indices = dt_sm[,which(get(data_col) > rr[2])]
dt_sm[lower_indices,(data_col) := rr[1]]
dt_sm[upper_indices,(data_col) := rr[2]]
lats = sort(unique(dt_sm[,lat]))
lons = sort(unique(dt_sm[,lon]))
dt_sm = dt_sm[!is.na(get(data_col))]
lon_dist = lons[2] - lons[1]
lat_dist = lats[2] - lats[1]
lon_range = range(lons) + c(-lon_dist/2-tol,lon_dist/2+tol)
lat_range = range(lats) + c(-lat_dist/2-tol,lat_dist/2+tol)
### plotting ###
pp = ggplot(data = dt_sm) +
geom_rect(xmin = min(lons) - lon_dist-tol,                             # add gray rectangle in the background, such that missing values appear gray
xmax = max(lons) + lon_dist+tol,
ymin = min(lats) - lat_dist-tol,
ymax = max(lats) + lat_dist+tol,fill = 'gray') +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = lon_range,ylim = lat_range,expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank())
if(!is.null(mn)) pp = pp + ggtitle(mn)                               # add title, if given
pp
source('~/pkg/ForecastTools/R/plotting.R')
source('~/pkg/ForecastTools/R/plotting.R')
pp = ggplot_dt(chirps_monthly[month == 10 & year == 2020], 'ano',
mn = 'October 2020 rainfall anomaly',
discrete_cs = TRUE,binwidth = 2,
low = 'red', mid = 'white', high = 'darkgreen',
midpoint = 0,
name = 'mm/day') +
geom_point(data = loc,mapping = aes(x = lon,y = lat)) +
geom_text(data = loc,mapping = aes(x = lon,y = lat,label = name),vjust = 1.5)
pp
source('~/pkg/ForecastTools/R/plotting.R')
pp = ggplot_dt(chirps_monthly[month == 10 & year == 2020], 'ano',
mn = 'October 2020 rainfall anomaly',
discrete_cs = TRUE,binwidth = 2,
low = 'red', mid = 'white', high = 'darkgreen',
midpoint = 0,
name = 'mm/day') +
geom_point(data = loc,mapping = aes(x = lon,y = lat)) +
geom_text(data = loc,mapping = aes(x = lon,y = lat,label = name),vjust = 1.5)
pp
source('~/pkg/ForecastTools/R/plotting.R')
source('~/pkg/ForecastTools/R/plotting.R')
pp = ggplot_dt(chirps_monthly[month == 10 & year == 2020], 'ano',
mn = 'October 2020 rainfall anomaly',
discrete_cs = TRUE,binwidth = 2,
low = 'red', mid = 'white', high = 'darkgreen',
midpoint = 0,
name = 'mm/day') +
geom_point(data = loc,mapping = aes(x = lon,y = lat)) +
geom_text(data = loc,mapping = aes(x = lon,y = lat,label = name),vjust = 1.5)
pp
ggplot_dt(chirps_monthly[month == 10 & year == 2020], 'ano',
mn = 'October 2020 rainfall anomaly',
discrete_cs = TRUE, binwidth = 2,
low = 'red', mid = 'white', high = 'darkgreen',
midpoint = 0,
name = 'mm/day')
ggplot_dt(chirps_monthly[month == 10 & year == 2020], 'obs',
mn = 'October 2020 rainfall',
mid = 'white', high = 'blue',
midpoint = 0,
name = 'mm/day')
ggplot_dt(chirps_monthly[month == 10 & year == 2020], 'ano',
mn = 'October 2020 rainfall anomaly',
discrete_cs = TRUE, binwidth = 2,
low = 'red', mid = 'white', high = 'darkgreen',
midpoint = 0,
name = 'mm/day')
pp = pp + scale_fill_viridis(name = 'my_color_scale',breaks = seq(-5,5,by = 2))
print(pp)
?scale_fill_viridis
pp = pp + scale_fill_viridis(name = 'my_color_scale',breaks = seq(-5,5,by = 2),na.value = 'pink',guide = 'legend')
print(pp)
pp = pp + scale_fill_viridis(name = 'my_color_scale',breaks = seq(-5,5,by = 2),na.value = 'pink',guide = 'legend')
print(pp)
pp = pp + scale_fill_viridis(name = 'my_color_scale',breaks = seq(-5,5,by = 2),na.value = 'red',guide = 'legend')
print(pp)
dt
data(countries)
countries
cs = as.data.table(countries)
cs
ct = 'Sudan'
cs = as.data.table(countries)[country == ct]
cs
dt
merge(dt,cs,by = c('lon','lat'))
restrict_to_country = function(dt,ct,rectangle = FALSE,tol = 0.5)
{
data(countries)
cs = as.data.table(countries)[country %in% ct]
if(!rectangle)
{
return(merge(dt,cs,by = c('lon','lat')[,country := NULL])
}
if(rectangle)
{
lon_range = range(cs[,lon]) + c(-tol,tol)
lat_range = range(cs[,lat]) + c(-tol,tol)
return(dt[lon %between% lon_range & lat %between% lat_range])
}
}
restrict_to_country = function(dt,ct,rectangle = FALSE,tol = 0.5)
{
data(countries)
cs = as.data.table(countries)[country %in% ct]
if(!rectangle)
{
return(merge(dt,cs,by = c('lon','lat')[,country := NULL])
}
if(rectangle)
{
lon_range = range(cs[,lon]) + c(-tol,tol)
lat_range = range(cs[,lat]) + c(-tol,tol)
return(dt[lon %between% lon_range & lat %between% lat_range])
}
}
restrict_to_country = function(dt,ct,rectangle = FALSE,tol = 0.5)
{
data(countries)
cs = as.data.table(countries)[country %in% ct]
if(!rectangle)
{
return(merge(dt,cs,by = c('lon','lat')[,country := NULL]))
}
if(rectangle)
{
lon_range = range(cs[,lon]) + c(-tol,tol)
lat_range = range(cs[,lat]) + c(-tol,tol)
return(dt[lon %between% lon_range & lat %between% lat_range])
}
}
dt_new = restrict_to_country(chirps_monthly[month == 10 & year == 2020],'Kenya')
source('~/pkg/SeaVal/R/utils.R')
dt_new = restrict_to_country(chirps_monthly[month == 10 & year == 2020],'Kenya')
dt_new
dt_new
ggplot_dt(dt_new, 'ano',
mn = 'October 2020 rainfall anomaly',
discrete_cs = TRUE, binwidth = 2,
low = 'red', mid = 'white', high = 'darkgreen',
midpoint = 0,
name = 'mm/day')
dt_new = restrict_to_country(chirps_monthly[month == 10 & year == 2020],'Kenya', rectangle = TRUE)
ggplot_dt(dt_new, 'ano',
mn = 'October 2020 rainfall anomaly',
discrete_cs = TRUE, binwidth = 2,
low = 'red', mid = 'white', high = 'darkgreen',
midpoint = 0,
name = 'mm/day')
dt_new = restrict_to_country(chirps_monthly[month == 10 & year == 2020],c('Kenya','Tanzania'),tol = 3)
ggplot_dt(dt_new, 'ano',
mn = 'October 2020 rainfall anomaly',
discrete_cs = TRUE, binwidth = 2,
low = 'red', mid = 'white', high = 'darkgreen',
midpoint = 0,
name = 'mm/day')
dt_new = restrict_to_country(chirps_monthly[month == 10 & year == 2020],c('Kenya','Tanzania'),rectangle = TRUE,tol = 3)
ggplot_dt(dt_new, 'ano',
mn = 'October 2020 rainfall anomaly',
discrete_cs = TRUE, binwidth = 2,
low = 'red', mid = 'white', high = 'darkgreen',
midpoint = 0,
name = 'mm/day')
dt_new = restrict_to_country(chirps_monthly[month == 10 & year == 2020],
c('Kenya','Tanzania'),
rectangle = TRUE,tol = 2)
ggplot_dt(dt_new, 'ano',
mn = 'October 2020 rainfall anomaly',
discrete_cs = TRUE, binwidth = 2,
low = 'red', mid = 'white', high = 'darkgreen',
midpoint = 0,
name = 'mm/day')
rm(list = ls())
library(PostProcessing)
devtools::load_all()
data("chirps_monthly")
print(chirps_monthly)
?chirps_monthly
# getting the climatology
clim_dt = chirps_monthly[,mean(prec),by = .(lon,lat)]
ggplot_dt(clim_dt)
#subsetting
chirps_monthly[month == 10] # extract the data for October
chirps_monthly[year %between% c(1990,1999)] # extract the data for 1990 - 1999
chirps_monthly[1000:2000] # extract rows 1000 - 2000
# computing
chirps_monthly[,prec]
rmarkdown::render('/nr/user/claudio/pkg/PostProcessing/scripts/CONFER/validation/01-getting_started_and_data_examples.Rmd')
getwd()
