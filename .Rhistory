rr
rr = dt_sm[,range(get(data_col),na.rm = T)]
colorscale = scale_fill_gradient2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint)
pp = pp + colorscale
pp
rr
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col)))
pp
pp = pp + colorscale
pp
colorscale$limits
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col)))
colorscale = scale_fill_gradient2(low = low,mid = mid,high = high)#,name = name,limits = rr,midpoint = midpoint,na.value = 'salmon',...)
pp = pp+colorscale
pp
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col)))
colorscale = scale_fill_gradient2(low = low,mid = mid,high = high,name = name)#,limits = rr,midpoint = midpoint,na.value = 'salmon',...)
pp = pp+colorscale
pp
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col)))
colorscale = scale_fill_gradient2(low = low,mid = mid,high = high,name = name,limits = rr)#,midpoint = midpoint,na.value = 'salmon',...)
pp = pp+colorscale
pp
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col)))
colorscale = scale_fill_gradient2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint)#,na.value = 'salmon',...)
pp = pp+colorscale
pp
midpoint
midpoint = rr[1] + (rr[2]-rr[1])/2
ggplot_dt_new = function(dt,
data_col = colnames(dt)[3],
mn = NULL, discrete_cs = FALSE,
rr = NULL,low = "blue", mid = "white", high = "red",name = data_col,midpoint = NULL,oob = scales::squish(),...,
binwidth = NULL,bin_midpoint = midpoint,
colorscale = NULL,
tol = 0)
{
####### transform data #######
# if you have spatio-temporal data, plot only only the first time-slice of it (convenient for diagnostics).
time_cols = intersect(names(dt),c('month','year','day','date','season'))
dt_sm = dt[,.SD,.SDcols = c('lon','lat',data_col,time_cols)]
if(length(time_cols)>0)
{
tc1 = dt_sm[1,.SD,.SDcols = time_cols]
dt_sm = merge(dt_sm,tc1,by = time_cols)
}
#### get map: ####
world_map <- ggplot2::map_data(map = 'world',resolution = 0)
# better maps are available with the rnaturalearth package and can be plotted using geom_sf.
# However, this approach requires gdal, so it's not exactly easily accessible.
#### fix range and set values outside of range to the range border ####
if(is.null(rr))
{
rr = dt_sm[,range(get(data_col),na.rm = T)]
}
# set midpoint and color scale
if(is.null(midpoint))
{
midpoint = rr[1] + (rr[2]-rr[1])/2
if(is.null(bin_midpoint))
{
bin_midpoint = midpoint
}
}
if(is.null(colorscale))
{
if(!discrete_cs)
{
colorscale = scale_fill_gradient2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,na.value = 'salmon',oob = oob,...)
}
if(discrete_cs)
{
if(!is.null(binwidth))
{
nbinapprox = floor((rr[2] - rr[1])/binwidth)
bins1 = binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins2 = -binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins=  sort(unique(c(bins2,bins1)))
bins = round(bins[bins %between% rr],2)
# for discrete scales there used to be an issue where the boundary bins are shown wider in the legend,
# see https://github.com/tidyverse/ggplot2/issues/4019. This was resolved in ggplot2 version 2.3.4.
colorscale = scale_fill_steps2(low = low, mid = mid, high = high, name = name, limits = rr, midpoint = midpoint, breaks = bins,oob = oob, ...)
}
if(is.null(binwidth))
{
colorscale = scale_fill_steps2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,oob = oob,...)
}
}
}
### plotting ###
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = range(dt_sm[,lon],na.rm = T),
ylim = range(dt_sm[,lat],na.rm = T),
expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank())
if(!is.null(mn)) pp = pp + ggtitle(mn)                               # add title, if given
return(pp)
}
ggplot_dt(pp)
ggplot_dt(dt)
ggplot_dt_new = function(dt,
data_col = colnames(dt)[3],
mn = NULL, discrete_cs = FALSE,
rr = NULL,low = "blue", mid = "white", high = "red",name = data_col,midpoint = NULL,oob = scales::squish(),...,
binwidth = NULL,bin_midpoint = midpoint,
colorscale = NULL,
tol = 0)
{
####### transform data #######
# if you have spatio-temporal data, plot only only the first time-slice of it (convenient for diagnostics).
time_cols = intersect(names(dt),c('month','year','day','date','season'))
dt_sm = dt[,.SD,.SDcols = c('lon','lat',data_col,time_cols)]
if(length(time_cols)>0)
{
tc1 = dt_sm[1,.SD,.SDcols = time_cols]
dt_sm = merge(dt_sm,tc1,by = time_cols)
}
#### get map: ####
world_map <- ggplot2::map_data(map = 'world',resolution = 0)
# better maps are available with the rnaturalearth package and can be plotted using geom_sf.
# However, this approach requires gdal, so it's not exactly easily accessible.
#### fix range and set values outside of range to the range border ####
if(is.null(rr))
{
rr = dt_sm[,range(get(data_col),na.rm = T)]
}
# set midpoint and color scale
if(is.null(midpoint))
{
midpoint = rr[1] + (rr[2]-rr[1])/2
if(is.null(bin_midpoint))
{
bin_midpoint = midpoint
}
}
if(is.null(colorscale))
{
if(!discrete_cs)
{
colorscale = scale_fill_gradient2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,na.value = 'salmon',oob = oob,...)
}
if(discrete_cs)
{
if(!is.null(binwidth))
{
nbinapprox = floor((rr[2] - rr[1])/binwidth)
bins1 = binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins2 = -binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins=  sort(unique(c(bins2,bins1)))
bins = round(bins[bins %between% rr],2)
# for discrete scales there used to be an issue where the boundary bins are shown wider in the legend,
# see https://github.com/tidyverse/ggplot2/issues/4019. This was resolved in ggplot2 version 2.3.4.
colorscale = scale_fill_steps2(low = low, mid = mid, high = high, name = name, limits = rr, midpoint = midpoint, breaks = bins,oob = oob, ...)
}
if(is.null(binwidth))
{
colorscale = scale_fill_steps2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,oob = oob,...)
}
}
}
### plotting ###
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = range(dt_sm[,lon],na.rm = T),
ylim = range(dt_sm[,lat],na.rm = T),
expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank())
if(!is.null(mn)) pp = pp + ggtitle(mn)                               # add title, if given
return(pp)
}
ggplot_dt_new(dt)
ggplot_dt_new = function(dt,
data_col = colnames(dt)[3],
mn = NULL, discrete_cs = FALSE,
rr = NULL,low = "blue", mid = "white", high = "red",name = data_col,midpoint = NULL,oob = scales::squish,...,
binwidth = NULL,bin_midpoint = midpoint,
colorscale = NULL,
tol = 0)
{
####### transform data #######
# if you have spatio-temporal data, plot only only the first time-slice of it (convenient for diagnostics).
time_cols = intersect(names(dt),c('month','year','day','date','season'))
dt_sm = dt[,.SD,.SDcols = c('lon','lat',data_col,time_cols)]
if(length(time_cols)>0)
{
tc1 = dt_sm[1,.SD,.SDcols = time_cols]
dt_sm = merge(dt_sm,tc1,by = time_cols)
}
#### get map: ####
world_map <- ggplot2::map_data(map = 'world',resolution = 0)
# better maps are available with the rnaturalearth package and can be plotted using geom_sf.
# However, this approach requires gdal, so it's not exactly easily accessible.
#### fix range and set values outside of range to the range border ####
if(is.null(rr))
{
rr = dt_sm[,range(get(data_col),na.rm = T)]
}
# set midpoint and color scale
if(is.null(midpoint))
{
midpoint = rr[1] + (rr[2]-rr[1])/2
if(is.null(bin_midpoint))
{
bin_midpoint = midpoint
}
}
if(is.null(colorscale))
{
if(!discrete_cs)
{
colorscale = scale_fill_gradient2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,na.value = 'salmon',oob = oob,...)
}
if(discrete_cs)
{
if(!is.null(binwidth))
{
nbinapprox = floor((rr[2] - rr[1])/binwidth)
bins1 = binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins2 = -binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins=  sort(unique(c(bins2,bins1)))
bins = round(bins[bins %between% rr],2)
# for discrete scales there used to be an issue where the boundary bins are shown wider in the legend,
# see https://github.com/tidyverse/ggplot2/issues/4019. This was resolved in ggplot2 version 2.3.4.
colorscale = scale_fill_steps2(low = low, mid = mid, high = high, name = name, limits = rr, midpoint = midpoint, breaks = bins,oob = oob, ...)
}
if(is.null(binwidth))
{
colorscale = scale_fill_steps2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,oob = oob,...)
}
}
}
### plotting ###
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = range(dt_sm[,lon],na.rm = T),
ylim = range(dt_sm[,lat],na.rm = T),
expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank())
if(!is.null(mn)) pp = pp + ggtitle(mn)                               # add title, if given
return(pp)
}
ggplot_dt_new(dt)
ggplot_dt_new(dt[!is.na(corr)])
?theme
### plotting ###
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = range(dt_sm[,lon],na.rm = T),
ylim = range(dt_sm[,lat],na.rm = T),
expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(rect = element_rect(fill =na.value),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank())
na.value = 'gray50
''
na.value = 'gray50'
na.value = 'gray50'
### plotting ###
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = range(dt_sm[,lon],na.rm = T),
ylim = range(dt_sm[,lat],na.rm = T),
expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(rect = element_rect(fill =na.value),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank())
pp
### plotting ###
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = range(dt_sm[,lon],na.rm = T),
ylim = range(dt_sm[,lat],na.rm = T),
expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(panel.background = element_rect(fill =na.value),
axis.text = element_blank(),
axis.ticks = element_blank())
pp
ggplot_dt_new = function(dt,
data_col = colnames(dt)[3],
mn = NULL, discrete_cs = FALSE,
rr = NULL,low = "blue", mid = "white", high = "red",name = data_col,midpoint = NULL,na.value = 'gray50',oob = scales::squish,...,
binwidth = NULL,bin_midpoint = midpoint,
colorscale = NULL,
tol = 0)
{
####### transform data #######
# if you have spatio-temporal data, plot only only the first time-slice of it (convenient for diagnostics).
time_cols = intersect(names(dt),c('month','year','day','date','season'))
dt_sm = dt[,.SD,.SDcols = c('lon','lat',data_col,time_cols)]
if(length(time_cols)>0)
{
tc1 = dt_sm[1,.SD,.SDcols = time_cols]
dt_sm = merge(dt_sm,tc1,by = time_cols)
}
#### get map: ####
world_map <- ggplot2::map_data(map = 'world',resolution = 0)
# better maps are available with the rnaturalearth package and can be plotted using geom_sf.
# However, this approach requires gdal, so it's not exactly easily accessible.
#### fix range and set values outside of range to the range border ####
if(is.null(rr))
{
rr = dt_sm[,range(get(data_col),na.rm = T)]
}
# set midpoint and color scale
if(is.null(midpoint))
{
midpoint = rr[1] + (rr[2]-rr[1])/2
if(is.null(bin_midpoint))
{
bin_midpoint = midpoint
}
}
if(is.null(colorscale))
{
if(!discrete_cs)
{
colorscale = scale_fill_gradient2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,na.value = na.value,oob = oob,...)
}
if(discrete_cs)
{
if(!is.null(binwidth))
{
nbinapprox = floor((rr[2] - rr[1])/binwidth)
bins1 = binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins2 = -binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins=  sort(unique(c(bins2,bins1)))
bins = round(bins[bins %between% rr],2)
# for discrete scales there used to be an issue where the boundary bins are shown wider in the legend,
# see https://github.com/tidyverse/ggplot2/issues/4019. This was resolved in ggplot2 version 2.3.4.
colorscale = scale_fill_steps2(low = low, mid = mid, high = high, name = name, limits = rr, midpoint = midpoint, breaks = bins,na.value = na.value,oob = oob, ...)
}
if(is.null(binwidth))
{
colorscale = scale_fill_steps2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,na.value = na.value,oob = oob,...)
}
}
}
### plotting ###
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = range(dt_sm[,lon],na.rm = T),
ylim = range(dt_sm[,lat],na.rm = T),
expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(panel.background = element_rect(fill =na.value),
axis.text = element_blank(),
axis.ticks = element_blank())
if(!is.null(mn)) pp = pp + ggtitle(mn)                               # add title, if given
return(pp)
}
ggplot_dt_new(dt)
ggplot_dt_new(dt[!is.na(corr)])
ggplot_dt_new = function(dt,
data_col = colnames(dt)[3],
mn = NULL, discrete_cs = FALSE,
rr = NULL,low = "blue", mid = "white", high = "red",name = data_col,midpoint = NULL,na.value = 'gray50',oob = scales::squish,...,
binwidth = NULL,bin_midpoint = midpoint,
colorscale = NULL,
tol = 0)
{
####### transform data #######
# if you have spatio-temporal data, plot only only the first time-slice of it (convenient for diagnostics).
time_cols = intersect(names(dt),c('month','year','day','date','season'))
dt_sm = dt[,.SD,.SDcols = c('lon','lat',data_col,time_cols)]
if(length(time_cols)>0)
{
tc1 = dt_sm[1,.SD,.SDcols = time_cols]
dt_sm = merge(dt_sm,tc1,by = time_cols)
}
#### get map: ####
world_map <- ggplot2::map_data(map = 'world',resolution = 0)
# better maps are available with the rnaturalearth package and can be plotted using geom_sf.
# However, this approach requires gdal, so it's not exactly easily accessible.
#### fix range and set values outside of range to the range border ####
if(is.null(rr))
{
rr = dt_sm[,range(get(data_col),na.rm = T)]
}
# set midpoint and color scale
if(is.null(midpoint))
{
midpoint = rr[1] + (rr[2]-rr[1])/2
if(is.null(bin_midpoint))
{
bin_midpoint = midpoint
}
}
if(is.null(colorscale))
{
if(!discrete_cs)
{
colorscale = scale_fill_gradient2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,na.value = na.value,oob = oob,...)
}
if(discrete_cs)
{
if(!is.null(binwidth))
{
nbinapprox = floor((rr[2] - rr[1])/binwidth)
bins1 = binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins2 = -binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins=  sort(unique(c(bins2,bins1)))
bins = round(bins[bins %between% rr],2)
# for discrete scales there used to be an issue where the boundary bins are shown wider in the legend,
# see https://github.com/tidyverse/ggplot2/issues/4019. This was resolved in ggplot2 version 2.3.4.
colorscale = scale_fill_steps2(low = low, mid = mid, high = high, name = name, limits = rr, midpoint = midpoint, breaks = bins,na.value = na.value,oob = oob, ...)
}
if(is.null(binwidth))
{
colorscale = scale_fill_steps2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,na.value = na.value,oob = oob,...)
}
}
}
### plotting ###
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = range(dt_sm[,lon],na.rm = T),
ylim = range(dt_sm[,lat],na.rm = T),
expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(panel.background = element_rect(fill =na.value), # this is required in case a data table is passed that has 'truely' missing locations, i.e. that is not rectangular
panel.grid = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank())
if(!is.null(mn)) pp = pp + ggtitle(mn)                               # add title, if given
return(pp)
}
ggplot_dt_new(dt[!is.na(corr)])
q(save = 'no')
q()
?scale_fill_gradient2
library(ggplot2)
?scale_fill_gradient2
knitr::opts_chunk$set(fig.width = 5)
knitr::opts_chunk$set(fig.height = 6)
library(SeaVal)
library(viridis) # the viridis package contains some nice color scales
pp_new = pp + scale_fill_viridis(name = 'my_color_scale',
breaks = seq(-5,5,by = 2),
oob = scales::censor,
na.value = 'salmon', # specify color for missing values
guide = guide_colorbar(title = 'my personal color scale',
title.position = 'top',
barwidth = 20,
direction = 'horizontal')) +
theme(legend.position = 'bottom')
library(SeaVal)
ggplot_dt
install.packages('SeaVal')
install.packages("SeaVal")
library(SeaVal)
ggplot_dt
q()
