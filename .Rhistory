library(ForecastTools)
library(SeaVal)
data_dir = '/nr/project/stat/CONFER/Data/validation/example_data/202101/'
cv_dt = cv_to_dt(data_dir)
print(cv_dt)
mse_dt = MSESS_dt(cv_dt,fc_col = 'prec',obs_col = 'obs')
print(mse_dt)
ggplot_dt(mse_dt,'MSESS',rr = c(-0.5,0.5))
mse_dt = add_countries(mse_dt)
mse_country_averaged = mse_dt[,.(MSE = mean(MSE),
clim_MSE = mean(clim_MSE),
MSESS = mean(MSESS)),
by = country]
print(mse_country_averaged)
devtools::document()
devtools::install_github('SeasonalForecastingEngine/ForecastTools')
devtools::install_github('SeasonalForecastingEngine/SeaVal')
library(data.table)
library(ForecastTools)
library(SeaVal)
data_dir = '/nr/project/stat/CONFER/Data/validation/example_data/202101/'
cv_dt = cv_to_dt(data_dir)
print(cv_dt)
devtools::install_github('SeasonalForecastingEngine/ForecastTools')
devtools::install_github('SeasonalForecastingEngine/SeaVal')
library(data.table)
library(ForecastTools)
library(SeaVal)
data_dir = '/nr/project/stat/CONFER/Data/validation/example_data/202101/'
cv_dt = cv_to_dt(data_dir)
print(cv_dt)
mse_dt = MSESS_dt(cv_dt,fc_col = 'prec',obs_col = 'obs')
print(mse_dt)
print(mse_dt)
ggplot_dt(mse_dt,'MSESS',rr = c(-0.5,0.5))
mse_dt = add_countries(mse_dt)
mse_country_averaged = mse_dt[,.(MSE = mean(MSE),
clim_MSE = mean(clim_MSE),
MSESS = mean(MSESS)),
by = country]
print(mse_country_averaged)
cv_dt[,prec_ano := prec - mean(prec), by = .(lon,lat)] # derive anomaly for each gridpoint
ggplot_dt(cv_dt,'prec_ano',rr = c(-10,10))
cv_dt[,obs_ano := obs - mean(obs), by = .(lon,lat)] # derive anomaly for each gridpoint
ggplot_dt(cv_dt,'obs_ano',rr = c(-10,10))
cv_dt[year == 2016,prec_ano := prec - mean(prec), by = .(lon,lat)] # derive anomaly for each gridpoint
ggplot_dt(cv_dt,'prec_ano',rr = c(-10,10))
cv_dt[,prec_ano := prec - mean(prec), by = .(lon,lat)] # derive anomaly for each gridpoint
ggplot_dt(cv_dt[year == 2016],'prec_ano',rr = c(-10,10))
cv_dt[,obs_ano := obs - mean(obs), by = .(lon,lat)] # derive anomaly for each gridpoint
ggplot_dt(cv_dt[year == 2016],'obs_ano',rr = c(-10,10))
rr = c(-15,15)
cv_dt[,prec_ano := prec - mean(prec), by = .(lon,lat)] # derive anomaly for each gridpoint
ggplot_dt(cv_dt[year == 2016],'prec_ano',rr = rr)
cv_dt[,obs_ano := obs - mean(obs), by = .(lon,lat)] # derive anomaly for each gridpoint
ggplot_dt(cv_dt[year == 2016],'obs_ano',rr = rr)
### some more example plots, here of 2016 predicted and observed anomalies: ###
rr = c(-25,25) # specify range of color scale
plot1 = ggplot_dt(cv_dt[year == 2016],'prec_ano',rr = rr) + ggtitle('predicted anomaly, 2016')
cv_dt[,prec_ano := prec - mean(prec), by = .(lon,lat)] # forecast anomaly
cv_dt[,obs_ano := obs - mean(obs), by = .(lon,lat)] # observed anomaly
rr = c(-25,25) # specify range of color scale
ggplot_dt(cv_dt[year == 2016],'prec_ano',rr = rr)
ggplot_dt(cv_dt[year == 2016],'obs_ano',rr = rr)
cv_dt
cv_dt[,bias := mean(prec) - mean(obs), by = .(lon,lat)]
#derive and plot model bias:
cv_dt[,bias := mean(prec) - mean(obs), by = .(lon,lat)]
ggplot_dt(cv_dt,'model_bias',rr = rr)
ggplot_dt(cv_dt,'bias',rr = rr)
ggplot_dt(cv_dt,'bias')
?cv_to_dt
library(data.table)
library(ForecastTools)
library(SeaVal)
# set this to the data directory containing the cross-validation data,
# at ICPAC that should be something like '~SharedData/gcm/seasonal/202101/'. If you are using windows, you might need to replace '/' by '\' instead...
data_dir = '/nr/project/stat/CONFER/Data/validation/example_data/202101/'
### get cross-validation results ###
cv_dt = cv_to_dt(data_dir)
print(cv_dt)
### derive MSE skill scores ###
mse_dt = MSESS_dt(cv_dt,fc_col = 'prec',obs_col = 'obs')
print(mse_dt)
### plot results ###
ggplot_dt(mse_dt,'MSESS',rr = c(-0.5,0.5)) # rr is the range of the color scale
### get result by
mse_dt = add_countries(mse_dt) # adds a country column to the data.table
mse_dt
mse_dt[country == 'Tanzania']
mse_dt[,unique(country)]
mse_dt[,country_index = match(country,unique(mse_dt[,country]))]
mse_dt[,country_index := match(country,unique(mse_dt[,country]))]
mse_dt
ggplot_dt(mse_dt,'country_index')
rm(list = ls())
library(data.table)
library(sp)
library(dplyr)
library(raster)
data_dir = '/nr/project/stat/CONFER/Data/'
data = getData('GADM')
country_list = c('Sudan','South Sudan','Ethiopia','Eritrea','Somalia','Kenya','Tanzania','Uganda','Rwanda','Djibouti','Burundi')
ISOs = as.data.table(getData('ISO3'))[NAME %in% country_list]
# weirdly enough, the getData function does not support doing multiple countries at the same time:
iso1 = ISOs[1,ISO3]
country1 = getData('GADM', country = iso1,level = 0)
pols = polygons(country1)
for(iso in ISOs[2:.N,ISO3])
{
cc = getData('GADM', country = iso,level = 0)
pols = rbind(pols, polygons(cc), makeUniqueIDs = TRUE)
}
### for full- and half-degree grids get the within-ICPAC locations as data.table:
full_deg_locs = as.data.table(expand.grid(lon = -179:180,lat = -90:90))
locs = SpatialPoints(full_deg_locs,proj4string = crs(pols))
full_deg_locs = as.data.table(coordinates(locs))[!is.na(over(locs,pols)),]
setkey(full_deg_locs,lon,lat)
half_deg_locs = as.data.table(expand.grid(lon = seq(-179,180,0.5),lat = seq(-90,90,0.5)))
locs = SpatialPoints(half_deg_locs,proj4string = crs(pols))
half_deg_locs = as.data.table(coordinates(locs))[!is.na(over(locs,pols)),]
setkey(half_deg_locs,lon,lat)
ICPAC_borders = copy(pols)
# save:
save(ICPAC_borders,full_deg_locs,half_deg_locs,file = paste0(data_dir,'ICPAC_region.RData'))
#######################
# get the half-degree-locations with countryname:
library(rworldmap)
countriesSP = getMap(resolution = 'high')
temp = SpatialPoints(half_deg_locs,proj4string = CRS(proj4string(countriesSP)))
indices = over(temp,countriesSP)
half_deg_locs[,country := indices$ADMIN]
plot_diagnostic(half_deg_locs,'country')
cs = unique(indices$ADMIN)
half_deg_locs[,country_ind := match(country,cs)]
ggplot_dt(half_deg_locs,'country_ind')
cs
as.character(cs)
nonGHAcs = c('Libya','Egypt','United Republic of Tanzania','Malawi','Mozambique','Somaliland')
correctedcs = c('Sudan','Sudan','Tanzania','Tanzania','Tanzania','Somalia')
correct_countries = function(cs)
{
cs_new = as.character(cs)
cs_new[cs_new %in% nonGHAcs] = correctedcs[match(cs_new[cs_new %in% nonGHAcs],nonGHAcs)]
return(cs_new)
}
correct_countries(nonGHAcs)
half_deg_locs[,country := correct_countries(country)]
half_deg_locs
half_deg_locs[,unique(country)]
half_deg_locs[,c('Lon','Lat','country_ind') := NULL]
fwrite(half_deg_locs,file = '/nr/project/stat/CONFER/Data/GHAcountries.csv')
dt = mse_dt
library(data.table)
library(ForecastTools)
library(SeaVal)
# set this to the data directory containing the cross-validation data,
# at ICPAC that should be something like '~SharedData/gcm/seasonal/202101/'. If you are using windows, you might need to replace '/' by '\' instead...
data_dir = '/nr/project/stat/CONFER/Data/validation/example_data/202101/'
### get cross-validation results ###
cv_dt = cv_to_dt(data_dir)
print(cv_dt)
### derive MSE skill scores ###
mse_dt = MSESS_dt(cv_dt,fc_col = 'prec',obs_col = 'obs')
print(mse_dt)
data(countries)
cs = as.data.table(countries)
cs
cs[,unique(country)]
cs = fread(file = '/nr/project/stat/CONFER/Data/GHAcountries.csv')
cs
cs[,unique(country)]
fwrite(cs,file = '~/pkg/SeaVal/data/countries.csv',sep = ';')
q(save = 'no')
install.packages('data.table')
library(ncdf4)
data_dir = '/nr/project/stat/CONFER/Data/validation/example_data/202101/'
library(ForecastTools)
library(ncdf4)
library(ForecastTools)
data_dir = '/nr/project/stat/CONFER/Data/validation/example_data/202101/'
# find cross-validation file
fns = list.files(data_dir)
fn = fns[grepl('CrossVal',fns)]
spec = strsplit(fn,split = '-')[[1]][2]
#get rid of year number:
target_months = strsplit(gsub("[[:digit:]]","",spec), split = '_')[[1]][1]
#' takes a character string consisting of capital letters of successive months.
#' Returns the indices of these months
months_to_numbers = function(str)
{
nmon = nchar(str)
allmons = 'JFMAMJJASOND'
# in case you go over 12:
allmons = paste0(allmons,allmons)
for(i in 1:12)
{
if(identical(substr(allmons,i,i+nmon-1),str))
{
mons = i:(i+nmon - 1)
}
}
mons = mons%%12
mons[mons == 0] = 12
return(mons)
}
convert_MonthsSinceDate_to_YearMonth = function(dt,timecol = 'time',origin = '1981-01-01')
{
or_mon = month(as.Date(origin))
or_year = year(as.Date(origin))
mons = (dt[,get(timecol)] + or_mon ) %% 12
mons[mons == 0] = 12
# in case the middle of the month is supplied (i.e. non-integer times):
mons = floor(mons)
years = (dt[,get(timecol)] + or_mon ) %/% 12 + or_year
years[mons == 12] = years[mons == 12] - 1
dt[,c('year','month') := list(years,mons)]
dt[,(timecol) := NULL]
return(dt)
}
target_months = months_to_numbers(target_months)
######### now get cross-validation data ############
nc_cv = ncdf4::nc_open(paste0(data_dir,fn))
cv_dt = ncdf_to_dt(nc_cv,printunits = F)
cv_dt
cv_dt[,unique(time)]
cv_dt = cv_dt[!is.na(prec)]
cv_dt = convert_MonthsSinceDate_to_YearMonth(cv_dt)
convert_MonthsSinceDate_to_YearMonth = function(dt,timecol = 'time',origin = '1981-01-01')
{
or_mon = month(as.Date(origin))
or_year = year(as.Date(origin))
mons = (dt[,get(timecol)] + or_mon ) %% 12
mons[mons == 0] = 12
# in case the middle of the month is supplied (i.e. non-integer times):
mons = floor(mons)
years = (dt[,get(timecol)] + or_mon ) %/% 12 + or_year
years[mons == 12] = years[mons == 12] - 1
dt[,c('year','month') := list(years,mons)]
dt[,(timecol) := NULL]
return(dt)
}
library(data.table)
library(PostProcessing)
#' takes a character string consisting of capital letters of successive months.
#' Returns the indices of these months
months_to_numbers = function(str)
{
nmon = nchar(str)
allmons = 'JFMAMJJASOND'
# in case you go over 12:
allmons = paste0(allmons,allmons)
for(i in 1:12)
{
if(identical(substr(allmons,i,i+nmon-1),str))
{
mons = i:(i+nmon - 1)
}
}
mons = mons%%12
mons[mons == 0] = 12
return(mons)
}
convert_MonthsSinceDate_to_YearMonth = function(dt,timecol = 'time',origin = '1981-01-01')
{
or_mon = month(as.Date(origin))
or_year = year(as.Date(origin))
mons = (dt[,get(timecol)] + or_mon ) %% 12
mons[mons == 0] = 12
# in case the middle of the month is supplied (i.e. non-integer times):
mons = floor(mons)
years = (dt[,get(timecol)] + or_mon ) %/% 12 + or_year
years[mons == 12] = years[mons == 12] - 1
dt[,c('year','month') := list(years,mons)]
dt[,(timecol) := NULL]
return(dt)
}
#' takes a character string consisting of capital letters of successive months.
#' Returns the indices of these months
months_to_numbers = function(str)
{
nmon = nchar(str)
allmons = 'JFMAMJJASOND'
# in case you go over 12:
allmons = paste0(allmons,allmons)
for(i in 1:12)
{
if(identical(substr(allmons,i,i+nmon-1),str))
{
mons = i:(i+nmon - 1)
}
}
mons = mons%%12
mons[mons == 0] = 12
return(mons)
}
cv_dt = convert_MonthsSinceDate_to_YearMonth(cv_dt)
cv_dt
cv_dt
cv_dt[,unique(month)]
obs_fn = paste0('ObservedRainfall-',spec)
nc_obs = ncdf4::nc_open(paste0(data_dir,obs_fn))
obs_dt = ncdf_to_dt(nc_obs,printunits = F)
obs_dt = obs_dt[!is.na(prec)]
obs_dt = convert_MonthsSinceDate_to_YearMonth(obs_dt)
obs_dt
obs_dt
obs_dt[,unique(month)]
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width = 6)
knitr::opts_chunk$set(fig.height = 6)
devtools::install_github('SeasonalForecastingEngine/SeaVal')
install.packages('rnaturalearth')
install.packages("rnaturalearth")
912*1.19
0.5*507
# These lines you only need when you don't have the packages installed:
install.packages('devtools')
install.packages('data.table')
install.packages("devtools")
install.packages("devtools")
install.packages("devtools")
install.packages("devtools")
q(save = 'no')
# These lines you only need when you don't have the packages installed:
install.packages('devtools')
install.packages('data.table')
# This should get you the two packages from Github:
devtools::install_github('SeasonalForecastingEngine/ForecastTools')
# setup:
library(SeaVal)
# set this to the data directory containing the cross-validation data,
# at ICPAC that should be something like '~SharedData/gcm/seasonal/202101/'. If you are using windows, you might need to replace '/' by '\' instead...
data_dir = '/nr/project/stat/CONFER/Data/validation/example_data/202101/'
### get cross-validation results ###
cv_dt = cv_to_dt(data_dir)
print(cv_dt)
### derive MSE skill scores ###
mse_dt = MSESS_dt(cv_dt,fc_col = 'prec',obs_col = 'obs')
print(mse_dt)
### plot results ###
ggplot_dt(mse_dt,'MSESS',rr = c(-0.5,0.5)) # rr is the range of the color scale
### get result by country ###
mse_dt = add_countries(mse_dt) # adds a country column to the data.table
mse_country_averaged = mse_dt[,.(MSE = mean(MSE), # averages the specified columns by country
clim_MSE = mean(clim_MSE),
MSESS = mean(MSESS)),
by = country]
# show results:
print(mse_country_averaged)
### some more example plots, here of 2016 predicted and observed anomalies, and of model bias: ###
# derive forecast- and observed anomalies:
cv_dt[,prec_ano := prec - mean(prec), by = .(lon,lat)] # forecast anomaly
cv_dt[,obs_ano := obs - mean(obs), by = .(lon,lat)] # observed anomaly
rr = c(-25,25) # specify range of color scale
ggplot_dt(cv_dt[year == 2016],'prec_ano',rr = rr)
ggplot_dt(cv_dt[year == 2016],'obs_ano',rr = rr)
#derive and plot model bias:
cv_dt[,bias := mean(prec) - mean(obs), by = .(lon,lat)]
ggplot_dt(cv_dt,'bias') # note that here we left out the rr argument for the range of the color scale, so it is determined automatically. It is by default centered at 0
# setup:
library(ForecastTools)
ggplot_dt(mse_dt,'MSESS',rr = c(-0.5,0.5)) # rr is the range of the color scale
q(save = 'no')
# These lines you only need when you don't have the packages installed:
install.packages('devtools')
# This should get you the two packages from Github:
devtools::install_github('SeasonalForecastingEngine/ForecastTools')
# setup:
library(SeaVal)
# set this to the data directory containing the cross-validation data,
# at ICPAC that should be something like '~SharedData/gcm/seasonal/202101/'. If you are using windows, you might need to replace '/' by '\' instead...
data_dir = '/nr/project/stat/CONFER/Data/validation/example_data/202101/'
### get cross-validation results ###
cv_dt = cv_to_dt(data_dir)
print(cv_dt)
### derive MSE skill scores ###
mse_dt = MSESS_dt(cv_dt,fc_col = 'prec',obs_col = 'obs')
print(mse_dt)
### plot results ###
ggplot_dt(mse_dt,'MSESS',rr = c(-0.5,0.5)) # rr is the range of the color scale
### get result by country ###
mse_dt = add_countries(mse_dt) # adds a country column to the data.table
mse_country_averaged = mse_dt[,.(MSE = mean(MSE), # averages the specified columns by country
clim_MSE = mean(clim_MSE),
MSESS = mean(MSESS)),
by = country]
# show results:
print(mse_country_averaged)
### some more example plots, here of 2016 predicted and observed anomalies, and of model bias: ###
# derive forecast- and observed anomalies:
cv_dt[,prec_ano := prec - mean(prec), by = .(lon,lat)] # forecast anomaly
cv_dt[,obs_ano := obs - mean(obs), by = .(lon,lat)] # observed anomaly
rr = c(-25,25) # specify range of color scale
ggplot_dt(cv_dt[year == 2016],'prec_ano',rr = rr)
ggplot_dt(cv_dt[year == 2016],'obs_ano',rr = rr)
#derive and plot model bias:
cv_dt[,bias := mean(prec) - mean(obs), by = .(lon,lat)]
ggplot_dt(cv_dt,'bias') # note that here we left out the rr argument for the range of the color scale, so it is determined automatically. It is by default centered at 0
q(save = 'no')
# These lines you only need when you don't have the packages installed:
install.packages('devtools')
# This should get you the two packages from Github:
devtools::install_github('SeasonalForecastingEngine/ForecastTools')
devtools::install_github('SeasonalForecastingEngine/SeaVal')
# setup:
library(SeaVal)
# set this to the data directory containing the cross-validation data,
# at ICPAC that should be something like '~SharedData/gcm/seasonal/202101/'. If you are using windows, you might need to replace '/' by '\' instead...
data_dir = '/nr/project/stat/CONFER/Data/validation/example_data/202101/'
### get cross-validation results ###
cv_dt = cv_to_dt(data_dir)
print(cv_dt)
### derive MSE skill scores ###
mse_dt = MSESS_dt(cv_dt,fc_col = 'prec',obs_col = 'obs')
print(mse_dt)
### plot results ###
ggplot_dt(mse_dt,'MSESS',rr = c(-0.5,0.5)) # rr is the range of the color scale
### get result by country ###
mse_dt = add_countries(mse_dt) # adds a country column to the data.table
mse_country_averaged = mse_dt[,.(MSE = mean(MSE), # averages the specified columns by country
clim_MSE = mean(clim_MSE),
MSESS = mean(MSESS)),
by = country]
# show results:
print(mse_country_averaged)
### some more example plots, here of 2016 predicted and observed anomalies, and of model bias: ###
# derive forecast- and observed anomalies:
cv_dt[,prec_ano := prec - mean(prec), by = .(lon,lat)] # forecast anomaly
cv_dt[,obs_ano := obs - mean(obs), by = .(lon,lat)] # observed anomaly
rr = c(-25,25) # specify range of color scale
ggplot_dt(cv_dt[year == 2016],'prec_ano',rr = rr)
ggplot_dt(cv_dt[year == 2016],'obs_ano',rr = rr)
#derive and plot model bias:
cv_dt[,bias := mean(prec) - mean(obs), by = .(lon,lat)]
ggplot_dt(cv_dt,'bias') # note that here we left out the rr argument for the range of the color scale, so it is determined automatically. It is by default centered at 0
getwd()
devtools::document()
q(save = 'no')
# These lines you only need when you don't have the packages installed:
install.packages('devtools')
# This should get you the two packages from Github:
devtools::install_github('SeasonalForecastingEngine/ForecastTools')
devtools::install_github('SeasonalForecastingEngine/SeaVal')
# setup:
library(SeaVal)
# set this to the data directory containing the cross-validation data,
# at ICPAC that should be something like '~SharedData/gcm/seasonal/202101/'. If you are using windows, you might need to replace '/' by '\' instead...
data_dir = '/nr/project/stat/CONFER/Data/validation/example_data/202101/'
### get cross-validation results ###
cv_dt = cv_to_dt(data_dir)
print(cv_dt)
### derive MSE skill scores ###
mse_dt = MSESS_dt(cv_dt,fc_col = 'prec',obs_col = 'obs')
print(mse_dt)
### plot results ###
ggplot_dt(mse_dt,'MSESS',rr = c(-0.5,0.5)) # rr is the range of the color scale
### get result by country ###
mse_dt = add_countries(mse_dt) # adds a country column to the data.table
mse_country_averaged = mse_dt[,.(MSE = mean(MSE), # averages the specified columns by country
clim_MSE = mean(clim_MSE),
MSESS = mean(MSESS)),
by = country]
# show results:
print(mse_country_averaged)
### some more example plots, here of 2016 predicted and observed anomalies, and of model bias: ###
# derive forecast- and observed anomalies:
cv_dt[,prec_ano := prec - mean(prec), by = .(lon,lat)] # forecast anomaly
cv_dt[,obs_ano := obs - mean(obs), by = .(lon,lat)] # observed anomaly
rr = c(-25,25) # specify range of color scale
ggplot_dt(cv_dt[year == 2016],'prec_ano',rr = rr)
ggplot_dt(cv_dt[year == 2016],'obs_ano',rr = rr)
#derive and plot model bias:
cv_dt[,bias := mean(prec) - mean(obs), by = .(lon,lat)]
ggplot_dt(cv_dt,'bias') # note that here we left out the rr argument for the range of the color scale, so it is determined automatically. It is by default centered at 0
q(save = 'no')
# These lines you only need when you don't have the package installed, so you only need to do this once:
install.packages('devtools')
devtools::install_github('SeasonalForecastingEngine/SeaVal')
# setup:
library(SeaVal)
# set this to the data directory containing the cross-validation data,
# at ICPAC that should be something like '~SharedData/gcm/seasonal/202101/'. If you are using windows, you might need to replace '/' by '\' instead...
data_dir = '/nr/project/stat/CONFER/Data/validation/example_data/202101/'
### get cross-validation results ###
cv_dt = cv_to_dt(data_dir)
print(cv_dt)
### derive MSE skill scores ###
mse_dt = MSESS_dt(cv_dt,fc_col = 'prec',obs_col = 'obs')
print(mse_dt)
### plot results ###
ggplot_dt(mse_dt,'MSESS',rr = c(-0.5,0.5)) # rr is the range of the color scale
### get result by country ###
mse_dt = add_countries(mse_dt) # adds a country column to the data.table
mse_country_averaged = mse_dt[,.(MSE = mean(MSE), # averages the specified columns by country
clim_MSE = mean(clim_MSE),
MSESS = mean(MSESS)),
by = country]
# show results:
print(mse_country_averaged)
### some more example plots, here of 2016 predicted and observed anomalies, and of model bias: ###
# derive forecast- and observed anomalies:
cv_dt[,prec_ano := prec - mean(prec), by = .(lon,lat)] # forecast anomaly
cv_dt[,obs_ano := obs - mean(obs), by = .(lon,lat)] # observed anomaly
rr = c(-25,25) # specify range of color scale
ggplot_dt(cv_dt[year == 2016],'prec_ano',rr = rr)
ggplot_dt(cv_dt[year == 2016],'obs_ano',rr = rr)
#derive and plot model bias:
cv_dt[,bias := mean(prec) - mean(obs), by = .(lon,lat)]
ggplot_dt(cv_dt,'bias') # note that here we left out the rr argument for the range of the color scale, so it is determined automatically. It is by default centered at 0
remove.packages(c('ForecastTools','SeaVal'))
q(save = 'no')
