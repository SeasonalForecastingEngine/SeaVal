
---
title: "The `SeaVal` package for validating seasonal weather forecasts"
author: "Claudio Heinrich"
output: html_document
---


# Getting Started


This tutorial gives a short introduction how to use the `R`-package `SeaVal` for seasonal validation. You can download the package directly from github as described below.
It provides a toolkit to evaluate predictions, tailored to specific needs of ICPAC. `SeaVal` relies on `R` data tables (available with the `R` package `data.table`).
Data tables are more flexible and memory efficient data frames, and simplify many operations that are frequently required when working with weather- and climate data. An introduction to data tables can be found here: https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html.
The package `SeaVal` allows to import netcdf-files as data tables. Moreover, it contains functionality for generating a variety of diagnostic plots, and provides various tools for forecast evaluation. In this tutorial we'll go over basic uses of this package, including examples for various evaluation scenarios.

## Installation

```{r setup, echo = F}
knitr::opts_chunk$set(echo = TRUE)

knitr::opts_chunk$set(fig.width = 6)
knitr::opts_chunk$set(fig.height = 6)

```


In order to directly install the package from github, you need the package `devtools`:
```{r eval = FALSE, echo = TRUE}
install.packages('devtools')
devtools::install_github('SeasonalForecastingEngine/SeaVal')
```

This installs `SeaVal` and all packages it depends on. This may take a while, especially if you didn't have some of the larger dependency packages installed, such as `data.table` or `ggplot2`.
Also, it is possible that you'll get a message like this:
```
These packages have more recent versions available.
It is recommended to update all of them.
Which would you like to update?

1: All                                 
2: CRAN packages only                  
3: None                             
...
```

In that case just type '1' for all. 

If this completes without an error, the setup is complete and you're good to go.
From here on out, all you have to do is load `SeaVal`:

```{r}
library(SeaVal)
```

Especially in the early development phase, it is important to occasionally update the `SeaVal` package. To this end simply run the following commands every now and then:
```{r, eval = FALSE, echo = TRUE}
devtools::install_github('SeasonalForecastingEngine/ForecastTools')
devtools::install_github('SeasonalForecastingEngine/SeaVal')
```

## examples of `data.table` syntax

Here, we show some examples of basic operations on data tables. 
A short but comprehensive introduction to `data.table`s syntax can be found (here)[https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html].
The `SeaVal` package comes with a few example data sets, for example monthly mean precipitation over the GHA region for the OND season provided by CHIRPS:

```{r}
data("chirps_monthly")
print(chirps_monthly)

```

We can look at a short description of the dataset like this:

```{r, eval = FALSE, echo = TRUE}
?chirps_monthly
```

We'll now go over a few basic commands for handling this sort of data. `chirps_monthly` is a data_table, which is an enhanced data frame. The most fundamental operations include subsetting, performing calculations on columns and aggregation or grouping for calculations. Examples for subsetting are
```{r}
chirps_monthly[month == 10] # extract the data for October
chirps_monthly[year %between% c(1990,1999)] # extract the data for 1990 - 1999
chirps_monthly[1000:2000] # extract rows 1000 - 2000
chirps_monthly[month == 10][lon > 30][terc_cat == 0] #chained subsetting: get all October values at locations with longitude >30 that had normal rainfall (terc_cat == 0)
chirps_monthly[month == 10 & lon > 30 & terc_cat == 0] # different syntax, same effect.
```
We can subset either by logical expressions or by row indices (third example above). Subsetting always returns a data table, e.g. `chirps_monthly[1]` returns a one-row data table containing the first row of `chirps_monthly`. 

Next, let's look at examples for operations on columns:
```{r}
chirps_monthly[,mean(prec)] # get the mean precipitation (over all locations, months, years)
chirps_monthly[,mean_prec := mean(prec)] # create a new column in the data table containing the mean
chirps_monthly[,prec := 30*prec] # transform precipitation from unit mm/day to mm (per month)
print(chirps_monthly)
```
Note in all cases the ',' after '[' which tells data table that you're doing an operation rather than trying to subset. We can also put things together and subset and operate simultaneously:
```{r}
chirps_monthly[month == 10 , mean(prec)] # get the mean precipitation for October (over all locations, years)
```
(Note that the mean is much larger now because we changed units...)
Finally, and most importantly, we can perform operations over aggregated groups: 
```{r}
dt_new = chirps_monthly[, mean(prec),by = .(lon,lat,month)] 
print(dt_new)
```
Here, the 'by' command (after the second comma) tells data table to perform the operation (`mean`) for each instance of `lon`, `lat`, and `month` separately. As a result, the mean is taken only over all years and we obtain the monthly local climatology. As we can see, the output is a data table containing all columns in `by` and a column named `V1` containing the output of the operation. That's of course a bit impractical. But it's easy to rename columns:

```{r}
setnames(dt_new,'V1','clim') # take the data table from above and rename column 'V1' into 'clim'
```
It's also possible to name the column direcly while `dt_new` is created, like this:
```{r}
dt_new = chirps_monthly[,.(clim = mean(prec)),by = .(lon,lat,month)] 
# same as above, but with simultaneously setting the name of the new column
```
This can again be combined with subsetting:
```{r}
dt_new = chirps_monthly[year %in% 1990:2020, .(clim = mean(prec)), by = .(lon,lat,month)] 
# computes climatology based on the years 1990-2020 only.
```
In the examples above we create a new data table containing the climatology. If we instead want to add the climatology as a new column to `chirps_monthly` directly, we need to use the `:=` operator:
```{r}
chirps_monthly[,clim := mean(prec), by = .(lon,lat,month)] # add the climatology column directly into chirps_monthly.
```
This showcases some of the main functionalities and syntax of the `data.table` package. As mentioned above, it is strongly recommended to have a look at 
(this introduction to `data.table`)[https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html], which introduces many more commands and properly explains the logic underlying `data.table`s syntax.
We'll finish this section by an example where we compute the MSE for raw ecmwf forecasts:

```{r}
data("chirps_monthly") # reload data to reverse the changes made in the examples above.
data("ecmwf_monthly") # get example hindcasts from ecmwf

print(ecmwf_monthly) 

# merge observations and predictions into a single data table:
setnames(chirps_monthly,'prec','obs') 
# rename the 'prec' column in the observation data table to 'obs', 
# in order to avoid name clashes, since ecmwf_monthly also contains a column 'prec',
# containing the predictions for precip.

dt = merge(ecmwf_monthly,chirps_monthly,
           by = c('lon','lat','year','month')) 
# merge hindcasts and observations into one data table.
print(dt)

dt[,ens_mean := mean(prec),by = .(lon,lat,year,month)] 
# get the ensemble mean as a new column. 
# The mean is here grouped over all dimension variables excluding 'member', 
# therefore the ensemble mean is returned. In other words, a separate mean
# is calculated for every instance of lon, lat, year and month.

mse_dt = dt[,.(mse = mean((prec-obs)^2)), by = .(lon,lat,month)] # create a new data.table containing the mse by location and month
print(mse_dt)

# plot mse for October:
ggplot_dt(mse_dt[month == 10],'mse',rr = c(-10,10) ) 

```

The function `ggplot_dt` is used to create spatial plots from data stored in data tables. The next section to this function and how the generated plots can be manipulated.
