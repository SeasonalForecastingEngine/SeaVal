dt_sm = dt[,.SD,.SDcols = c('lon','lat',data_col,time_cols)]
if(length(time_cols)>0)
{
tc1 = dt_sm[1,.SD,.SDcols = time_cols]
dt_sm = merge(dt_sm,tc1,by = time_cols)
}
#### get map: ####
world_map <- ggplot2::map_data(map = 'world',resolution = 0)
# better maps are available with the rnaturalearth package and can be plotted using geom_sf.
# However, this approach requires gdal, so it's not exactly easily accessible.
#### fix range and set values outside of range to the range border ####
if(is.null(rr))
{
rr = dt_sm[,range(get(data_col),na.rm = T)]
}
# set midpoint and color scale
if(is.null(midpoint))
{
midpoint = rr[1] + (rr[2]-rr[1])/2
if(is.null(bin_midpoint))
{
bin_midpoint = midpoint
}
}
if(is.null(colorscale))
{
if(!discrete_cs)
{
colorscale = scale_fill_gradient2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,na.value = 'salmon',oob = oob,...)
}
if(discrete_cs)
{
if(!is.null(binwidth))
{
nbinapprox = floor((rr[2] - rr[1])/binwidth)
bins1 = binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins2 = -binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins=  sort(unique(c(bins2,bins1)))
bins = round(bins[bins %between% rr],2)
# for discrete scales there used to be an issue where the boundary bins are shown wider in the legend,
# see https://github.com/tidyverse/ggplot2/issues/4019. This was resolved in ggplot2 version 2.3.4.
colorscale = scale_fill_steps2(low = low, mid = mid, high = high, name = name, limits = rr, midpoint = midpoint, breaks = bins,oob = oob, ...)
}
if(is.null(binwidth))
{
colorscale = scale_fill_steps2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,oob = oob,...)
}
}
}
### plotting ###
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = range(dt_sm[,lon],na.rm = T),
ylim = range(dt_sm[,lat],na.rm = T),
expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank())
if(!is.null(mn)) pp = pp + ggtitle(mn)                               # add title, if given
return(pp)
}
ggplot_dt_new(dt)
ggplot_dt_new = function(dt,
data_col = colnames(dt)[3],
mn = NULL, discrete_cs = FALSE,
rr = NULL,low = "blue", mid = "white", high = "red",name = data_col,midpoint = NULL,oob = scales::squish,...,
binwidth = NULL,bin_midpoint = midpoint,
colorscale = NULL,
tol = 0)
{
####### transform data #######
# if you have spatio-temporal data, plot only only the first time-slice of it (convenient for diagnostics).
time_cols = intersect(names(dt),c('month','year','day','date','season'))
dt_sm = dt[,.SD,.SDcols = c('lon','lat',data_col,time_cols)]
if(length(time_cols)>0)
{
tc1 = dt_sm[1,.SD,.SDcols = time_cols]
dt_sm = merge(dt_sm,tc1,by = time_cols)
}
#### get map: ####
world_map <- ggplot2::map_data(map = 'world',resolution = 0)
# better maps are available with the rnaturalearth package and can be plotted using geom_sf.
# However, this approach requires gdal, so it's not exactly easily accessible.
#### fix range and set values outside of range to the range border ####
if(is.null(rr))
{
rr = dt_sm[,range(get(data_col),na.rm = T)]
}
# set midpoint and color scale
if(is.null(midpoint))
{
midpoint = rr[1] + (rr[2]-rr[1])/2
if(is.null(bin_midpoint))
{
bin_midpoint = midpoint
}
}
if(is.null(colorscale))
{
if(!discrete_cs)
{
colorscale = scale_fill_gradient2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,na.value = 'salmon',oob = oob,...)
}
if(discrete_cs)
{
if(!is.null(binwidth))
{
nbinapprox = floor((rr[2] - rr[1])/binwidth)
bins1 = binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins2 = -binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins=  sort(unique(c(bins2,bins1)))
bins = round(bins[bins %between% rr],2)
# for discrete scales there used to be an issue where the boundary bins are shown wider in the legend,
# see https://github.com/tidyverse/ggplot2/issues/4019. This was resolved in ggplot2 version 2.3.4.
colorscale = scale_fill_steps2(low = low, mid = mid, high = high, name = name, limits = rr, midpoint = midpoint, breaks = bins,oob = oob, ...)
}
if(is.null(binwidth))
{
colorscale = scale_fill_steps2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,oob = oob,...)
}
}
}
### plotting ###
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = range(dt_sm[,lon],na.rm = T),
ylim = range(dt_sm[,lat],na.rm = T),
expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank())
if(!is.null(mn)) pp = pp + ggtitle(mn)                               # add title, if given
return(pp)
}
ggplot_dt_new(dt)
ggplot_dt_new(dt[!is.na(corr)])
?theme
### plotting ###
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = range(dt_sm[,lon],na.rm = T),
ylim = range(dt_sm[,lat],na.rm = T),
expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(rect = element_rect(fill =na.value),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank())
na.value = 'gray50
''
na.value = 'gray50'
na.value = 'gray50'
### plotting ###
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = range(dt_sm[,lon],na.rm = T),
ylim = range(dt_sm[,lat],na.rm = T),
expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(rect = element_rect(fill =na.value),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank())
pp
### plotting ###
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = range(dt_sm[,lon],na.rm = T),
ylim = range(dt_sm[,lat],na.rm = T),
expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(panel.background = element_rect(fill =na.value),
axis.text = element_blank(),
axis.ticks = element_blank())
pp
ggplot_dt_new = function(dt,
data_col = colnames(dt)[3],
mn = NULL, discrete_cs = FALSE,
rr = NULL,low = "blue", mid = "white", high = "red",name = data_col,midpoint = NULL,na.value = 'gray50',oob = scales::squish,...,
binwidth = NULL,bin_midpoint = midpoint,
colorscale = NULL,
tol = 0)
{
####### transform data #######
# if you have spatio-temporal data, plot only only the first time-slice of it (convenient for diagnostics).
time_cols = intersect(names(dt),c('month','year','day','date','season'))
dt_sm = dt[,.SD,.SDcols = c('lon','lat',data_col,time_cols)]
if(length(time_cols)>0)
{
tc1 = dt_sm[1,.SD,.SDcols = time_cols]
dt_sm = merge(dt_sm,tc1,by = time_cols)
}
#### get map: ####
world_map <- ggplot2::map_data(map = 'world',resolution = 0)
# better maps are available with the rnaturalearth package and can be plotted using geom_sf.
# However, this approach requires gdal, so it's not exactly easily accessible.
#### fix range and set values outside of range to the range border ####
if(is.null(rr))
{
rr = dt_sm[,range(get(data_col),na.rm = T)]
}
# set midpoint and color scale
if(is.null(midpoint))
{
midpoint = rr[1] + (rr[2]-rr[1])/2
if(is.null(bin_midpoint))
{
bin_midpoint = midpoint
}
}
if(is.null(colorscale))
{
if(!discrete_cs)
{
colorscale = scale_fill_gradient2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,na.value = na.value,oob = oob,...)
}
if(discrete_cs)
{
if(!is.null(binwidth))
{
nbinapprox = floor((rr[2] - rr[1])/binwidth)
bins1 = binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins2 = -binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins=  sort(unique(c(bins2,bins1)))
bins = round(bins[bins %between% rr],2)
# for discrete scales there used to be an issue where the boundary bins are shown wider in the legend,
# see https://github.com/tidyverse/ggplot2/issues/4019. This was resolved in ggplot2 version 2.3.4.
colorscale = scale_fill_steps2(low = low, mid = mid, high = high, name = name, limits = rr, midpoint = midpoint, breaks = bins,na.value = na.value,oob = oob, ...)
}
if(is.null(binwidth))
{
colorscale = scale_fill_steps2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,na.value = na.value,oob = oob,...)
}
}
}
### plotting ###
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = range(dt_sm[,lon],na.rm = T),
ylim = range(dt_sm[,lat],na.rm = T),
expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(panel.background = element_rect(fill =na.value),
axis.text = element_blank(),
axis.ticks = element_blank())
if(!is.null(mn)) pp = pp + ggtitle(mn)                               # add title, if given
return(pp)
}
ggplot_dt_new(dt)
ggplot_dt_new(dt[!is.na(corr)])
ggplot_dt_new = function(dt,
data_col = colnames(dt)[3],
mn = NULL, discrete_cs = FALSE,
rr = NULL,low = "blue", mid = "white", high = "red",name = data_col,midpoint = NULL,na.value = 'gray50',oob = scales::squish,...,
binwidth = NULL,bin_midpoint = midpoint,
colorscale = NULL,
tol = 0)
{
####### transform data #######
# if you have spatio-temporal data, plot only only the first time-slice of it (convenient for diagnostics).
time_cols = intersect(names(dt),c('month','year','day','date','season'))
dt_sm = dt[,.SD,.SDcols = c('lon','lat',data_col,time_cols)]
if(length(time_cols)>0)
{
tc1 = dt_sm[1,.SD,.SDcols = time_cols]
dt_sm = merge(dt_sm,tc1,by = time_cols)
}
#### get map: ####
world_map <- ggplot2::map_data(map = 'world',resolution = 0)
# better maps are available with the rnaturalearth package and can be plotted using geom_sf.
# However, this approach requires gdal, so it's not exactly easily accessible.
#### fix range and set values outside of range to the range border ####
if(is.null(rr))
{
rr = dt_sm[,range(get(data_col),na.rm = T)]
}
# set midpoint and color scale
if(is.null(midpoint))
{
midpoint = rr[1] + (rr[2]-rr[1])/2
if(is.null(bin_midpoint))
{
bin_midpoint = midpoint
}
}
if(is.null(colorscale))
{
if(!discrete_cs)
{
colorscale = scale_fill_gradient2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,na.value = na.value,oob = oob,...)
}
if(discrete_cs)
{
if(!is.null(binwidth))
{
nbinapprox = floor((rr[2] - rr[1])/binwidth)
bins1 = binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins2 = -binwidth*(1/2 + (0:nbinapprox)) + bin_midpoint
bins=  sort(unique(c(bins2,bins1)))
bins = round(bins[bins %between% rr],2)
# for discrete scales there used to be an issue where the boundary bins are shown wider in the legend,
# see https://github.com/tidyverse/ggplot2/issues/4019. This was resolved in ggplot2 version 2.3.4.
colorscale = scale_fill_steps2(low = low, mid = mid, high = high, name = name, limits = rr, midpoint = midpoint, breaks = bins,na.value = na.value,oob = oob, ...)
}
if(is.null(binwidth))
{
colorscale = scale_fill_steps2(low = low,mid = mid,high = high,name = name,limits = rr,midpoint = midpoint,na.value = na.value,oob = oob,...)
}
}
}
### plotting ###
pp = ggplot(data = dt_sm) +
geom_tile(aes(x = lon,y = lat, fill = get(data_col))) +            # add data plot
geom_polygon(data = world_map,
mapping = aes(x = long,y = lat,group = group),
color = 'black',fill = NA,size=0.25)  +               # add map
colorscale +  # colorscale is specified above
coord_cartesian(xlim = range(dt_sm[,lon],na.rm = T),
ylim = range(dt_sm[,lat],na.rm = T),
expand = FALSE) + # restricts the plot to exactly the considered area to avoid weird borders
#coord_sf(xlim = lon_range,ylim = lat_range,expand = FALSE) +       # restricts the plot to exactly the considered area to avoid weird borders
xlab('') + ylab('') +                                              # remove default labels and background grid...
theme(panel.background = element_rect(fill =na.value), # this is required in case a data table is passed that has 'truely' missing locations, i.e. that is not rectangular
panel.grid = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank())
if(!is.null(mn)) pp = pp + ggtitle(mn)                               # add title, if given
return(pp)
}
ggplot_dt_new(dt[!is.na(corr)])
q(save = 'no')
q()
?scale_fill_gradient2
library(ggplot2)
?scale_fill_gradient2
knitr::opts_chunk$set(fig.width = 5)
knitr::opts_chunk$set(fig.height = 6)
library(SeaVal)
library(viridis) # the viridis package contains some nice color scales
pp_new = pp + scale_fill_viridis(name = 'my_color_scale',
breaks = seq(-5,5,by = 2),
oob = scales::censor,
na.value = 'salmon', # specify color for missing values
guide = guide_colorbar(title = 'my personal color scale',
title.position = 'top',
barwidth = 20,
direction = 'horizontal')) +
theme(legend.position = 'bottom')
library(SeaVal)
ggplot_dt
install.packages('SeaVal')
install.packages("SeaVal")
library(SeaVal)
ggplot_dt
q()
### This script renders the SeaVal documentation
# It essentially knits all .rmd files in this folder, starting with index.rmd and then following the naming order (so the file names should start with a number)
setwd('~/pkg/SeaVal/scripts/SeaValDocumentation/bookdown/') # adjust to your local repository!
bookdown::render_book('index.rmd',
'bookdown::gitbook',
new_session = T)
# We need to copy paste, the output_dir option of render_book does not work, see https://github.com/rstudio/bookdown/issues/804
output_dir = '/nr/common/www/virtual/files.nr.no/htdocs/samba/CONFER/SeaVal/'# this directory is shared at http://files.nr.no/samba/CONFER/SeaVal/
file.copy(from = './_book/', to = output_dir, recursive = TRUE)
library(SeaVal)
library(SeaVal)
library(ggpubr)
library(ggplot2)
data_dir = '/nr/project/stat/CONFER/Data/validation/example_data/202102/' # the directory the data is stored in
dt = netcdf_to_dt(paste0(data_dir,'PredictedProbabilityRain_Mar-May_Feb2021_new.nc'))
print(dt)
dt_obs = netcdf_to_dt(paste0(data_dir,'ObservedRain_Mar-May_Feb2021.nc'))
dt_obs2021 = netcdf_to_dt(paste0(data_dir,'ObservedChirpsRainTotal_MAM2021.nc'),vars = 'precip')
# the 2021 observation is on finer scale:
setnames(dt_obs2021,c('longitude','latitude','precip'),c('lon','lat','prec'))
ggplot_dt(dt_obs2021,'prec',high = 'blue',midpoint = 0)
# we can upscale it to half-degree-resolution using the following function:
dt_obs2021 = upscale_to_half_degrees(dt_obs2021,uscol = 'prec',bycols = 'time')
dt = dt_obs2021
uscol = 'prec'
dt
bycols = 'time'
fine_grid = unique(dt[!is.na(get(uscol)),.(lon,lat)])
setkey(fine_grid,lon,lat)
fine_grid
# get the grid box extend
min_lon = floor(2*fine_grid[,min(lon)])/2
min_lat = floor(2*fine_grid[,min(lat)])/2
max_lon = ceiling(2*fine_grid[,max(lon)])/2
max_lat = ceiling(2*fine_grid[,max(lat)])/2
fine_grid[,clon1 := floor(2*lon)/2][,clat1 := floor(2*lat)/2]
fine_grid[,clon2 := floor(2*lon)/2 + 0.5][,clat2 := floor(2*lat)/2]
fine_grid[,clon3 := floor(2*lon)/2 + 0.5][,clat3 := floor(2*lat)/2 + 0.5]
fine_grid[,clon4 := floor(2*lon)/2][,clat4 := floor(2*lat)/2 + 0.5]
# get rectangle overlap:
rect_intersect = function(center_x1,center_y1,center_x2,center_y2,l1,l2)
{
x_overlap = pmin(center_x1 + l1/2, center_x2 + l2/2) - pmax(center_x1 - l1/2,center_x2 - l2/2)
x_overlap = pmax(x_overlap,0)
y_overlap = pmin(center_y1 + l1/2, center_y2 + l2/2) - pmax(center_y1 - l1/2,center_y2 - l2/2)
y_overlap = pmax(y_overlap,0)
return(x_overlap * y_overlap)
}
for(ii in 1:4)
{
fine_grid[,paste0('ol',ii) := rect_intersect(center_x1 = lon,
center_y1 = lat,
center_x2 = get(paste0('clon',ii)),
center_y2 = get(paste0('clat',ii)),
l1 = grid_size_fine_grid,
l2 = 0.5)]
}
temp = sort(unique(fine_grid[,lon]))
temp
grid_size_fine_grid = temp[2] - temp[1]
grid_size_fine_grid
grid_size_fine_grid = round(temp[2] - temp[1],3)
grid_size_fine_grid
grid_size_fine_grid = round(temp[2] - temp[1],5) # round, because of instabilities
grid_size_fine_grid
for(ii in 1:4)
{
fine_grid[,paste0('ol',ii) := rect_intersect(center_x1 = lon,
center_y1 = lat,
center_x2 = get(paste0('clon',ii)),
center_y2 = get(paste0('clat',ii)),
l1 = grid_size_fine_grid,
l2 = 0.5)]
}
coarse_grid = as.data.table(expand.grid(lon = seq(min_lon,max_lon,0.5), lat = seq(min_lat,max_lat,0.5)))
setkey(coarse_grid,lon,lat)
fine_grid[,index_fine:= 1:.N]
coarse_grid[,index_coarse:= 1:.N]
### get weight matrices ###
for(ind in 1:4)
{
temp = copy(coarse_grid)
setnames(temp,c(paste0('c',c('lon','lat'),ind),paste0('ic',ind)))
fine_grid = merge(fine_grid,temp,by = paste0('c',c('lon','lat'),ind))
setkey(fine_grid,lon,lat)
assign(paste0('Mat',ind),value = Matrix::sparseMatrix(i = fine_grid[,get(paste0('ic',ind))],
j = fine_grid[,index_fine],
x = fine_grid[,get(paste0('ol',ind))],
dims = c(coarse_grid[,.N],fine_grid[,.N])))
}
multipl_matrix = Mat1 + Mat2 + Mat3 + Mat4
rs = rowSums(multipl_matrix)
weight_inverter = rep(0,length(rs))
weight_inverter[abs(rs) > 1e-5] = 1/rs[abs(rs) > 1e-5]
multipl_matrix
Mat1
is(Mat1)
rs = Matrix::rowSums(multipl_matrix)
weight_inverter = rep(0,length(rs))
weight_inverter[abs(rs) > 1e-5] = 1/rs[abs(rs) > 1e-5]
weight_mat =   multipl_matrix * weight_inverter
coarse_grid[,inGHA := abs(rs) > 1e-5]
dt = dt[!is.na(prec)]
dt_new = data.table()
setkeyv(dt,c(bycols,'lon','lat'))
setkey(fine_grid,lon,lat)
setkey(coarse_grid,lon,lat)
levels = dt[lon == lon[1] & lat == lat[1],.SD,.SDcols = bycols]
for(ll in 1:levels[,.N])
{
ll_sub = levels[ll]
print(paste0(ll,'/',levels[,.N]))
temp = dt[ll_sub]
setkey(temp,lon,lat)
new_vals = weight_mat %*% temp[,get(uscol)]
temp2 = copy(coarse_grid)
temp2[,(uscol):= as.vector(new_vals)]
temp2 = cbind(temp2,ll_sub)
dt_new = rbindlist(list(dt_new,temp2))
}
dt_new[!(inGHA),(uscol) := NA]
dt_new[,inGHA := NULL][,index_coarse:=NULL]
dt_new
devtools::document()
q()
