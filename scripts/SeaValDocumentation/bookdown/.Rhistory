by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)),
along_cols = c('year'))
{
if(range(fc_dt[,get(fc_col)],na.rm = T)[2] > 1) stop('your predictions should be values between 0 and 1.')
if(is.logical(fc_dt[,get(obs_col)]))
{
Score_dt = fc_dt[,.(BS_ex = (get(fc_col)-get(obs_col))^2),by = c(by_cols,threshold_col)]# the by-arguments are for keeping these columns only
}
if(!is.logical(fc_dt[,get(obs_col)]))
{
Score_dt = fc_dt[,.(BS_ex = (get(fc_col) - (get(obs_col) > get(threshold_col)))^2),by = c(by_cols,threshold_col)]
}
return(Score_dt)
}
climatology_threshold_exceedence = function(obs_dt,
obs_col = 'prec',
by_cols = intersect(c('lon','lat','month','season'),names(obs_dt)),
thresholds = c(200,300,350,400))
{
clim_dt = climatology_ens_forecast(obs_dt,by_cols = by_cols)
ret_dt = data.table()
for(thr in thresholds)
{
thr_dt = clim_dt[,.(pexcd = mean(get(obs_col) > thr)),by = c(by_cols,'year')]
thr_dt[,threshold := thr]
ret_dt = rbindlist(list(ret_dt,thr_dt))
}
return(ret_dt)
}
#' Calculate exceedence Brier skill score
#'
#' @param fc_dt Data table containing the predictions.
#' @param fc_col column name of the prediction. Contains predicted probabilities of exceedence
#' @param threshold_col which column contains the exceedence threshold?
#' @param obs_col column name of the observations, that is
#' @param by_cols column names of grouping variables, all of which need to be columns in fc_dt.
#' Default is to group by all instances of month, season, lon, lat, system and lead_time that are columns in fc_dt.
#' @export
BSS_ex_dt = function(fc_dt,
fc_col,
clim_col = 'clim',
threshold_col,
obs_col = 'obs',
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)))
{
es_dt = BS_ex_dt(fc_dt = fc_dt,
fc_col = fc_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
clim_es_dt = BS_ex_dt(fc_dt = fc_dt,
fc_col = clim_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
setnames(clim_es_dt,'BS_ex','clim_BS_ex')
score_dt = merge(es_dt,clim_es_dt,by = intersect(names(es_dt),names(clim_es_dt)))
score_dt[,BSS_ex := (clim_BS_ex - BS_ex)/clim_BS_ex ]
#deal with divisions by 0:
es_dt[clim_BS_ex == 0 & BS_ex == 0, BSS_ex := 0] # when both are perfect, skill score should be 0
es_dt[clim_BS_ex == 0 & BS_ex > 0, BSS_ex := min(min(BSS_ex,na.rm = T), -1)] # set to something negative (capped at -1), when climatology predicts perfectly and the forecast does not
#(should actually -Inf, but that's bad for plotting).
return(es_dt)
}
clim_fc = climatology_threshold_exceedence(dt_obs,
obs_col = 'prec',
thresholds = unique(dt[,rthr]),
by_cols = c('month','lon','lat'))
print(clim_fc)
setnames(clim_fc,c('pexcd','threshold'),c('clim','rthr'))
dt = merge(dt,clim_fc[year == 2021,],by = c('lon','lat','month','rthr'))
dt = merge(dt,dt_obs[year == 2021],by = c('lon','lat','month','year'))
print(dt)
ggplot_dt(dt[month == 2 & model == 'GEM-NEMO' & rthr == 200],'pexcd')
ggplot_dt(dt[month == 2 & model == 'GEM-NEMO' & rthr == 200],'prec')
dt[,pexcd := pexcd/100]
bss_dt = BSS_ex_dt(dt,fc_col = 'pexcd',threshold_col = 'rthr',obs_col = 'prec',by_cols = c('model','month','lon','lat'))
BS_ex_dt = BS_ex_dt(dt,'pexcd','rthr',obs_col = 'prec',by_cols = c('model','month','lon','lat'))
plot_list = list()
for(mod in unique(bss_dt[,model]))
{
plot_list = c(plot_list,list(ggplot_dt(bss_dt[model == mod& month == 3 & rthr == 200],'BSS_ex',mn = mod, high = 'red',midpoint = 0,rr= c(-1,1))))
}
fc_dt = dt
fc_col = 'pexcd'
threshold_col = 'rthr'
obs_col = 'prec'
by_cols = c('model','month','lon','lat')
BS_dt = BS_ex_dt(fc_dt = fc_dt,
fc_col = fc_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
BS_ex_dt = function(fc_dt,fc_col,threshold_col,
obs_col = 'obs',
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)),
along_cols = c('year'))
{
if(range(fc_dt[,get(fc_col)],na.rm = T)[2] > 1) stop('your predictions should be values between 0 and 1.')
if(is.logical(fc_dt[,get(obs_col)]))
{
Score_dt = fc_dt[,.(BS_ex = (get(fc_col)-get(obs_col))^2),by = c(by_cols,threshold_col)]# the by-arguments are for keeping these columns only
}
if(!is.logical(fc_dt[,get(obs_col)]))
{
Score_dt = fc_dt[,.(BS_ex = (get(fc_col) - (get(obs_col) > get(threshold_col)))^2),by = c(by_cols,threshold_col)]
}
return(Score_dt)
}
BS_dt = BS_ex_dt(fc_dt = fc_dt,
fc_col = fc_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
clim_es_dt = BS_ex_dt(fc_dt = fc_dt,
fc_col = clim_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
setnames(clim_es_dt,'BS_ex','clim_BS_ex')
score_dt = merge(es_dt,clim_es_dt,by = intersect(names(es_dt),names(clim_es_dt)))
score_dt[,BSS_ex := (clim_BS_ex - BS_ex)/clim_BS_ex ]
score_dt
score_dt = merge(BS_dt,clim_es_dt,by = intersect(names(es_dt),names(clim_es_dt)))
score_dt[,BSS_ex := (clim_BS_ex - BS_ex)/clim_BS_ex ]
#deal with divisions by 0:
es_dt[clim_BS_ex == 0 & BS_ex == 0, BSS_ex := 0] # when both are perfect, skill score should be 0
#deal with divisions by 0:
score_dt[clim_BS_ex == 0 & BS_ex == 0, BSS_ex := 0] # when both are perfect, skill score should be 0
score_dt[clim_BS_ex == 0 & BS_ex > 0, BSS_ex := min(min(BSS_ex,na.rm = T), -1)] # set to something negative (capped at -1), when climatology predicts perfectly and the forecast does not
BSS_ex_dt = function(fc_dt,
fc_col,
clim_col = 'clim',
threshold_col,
obs_col = 'obs',
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)))
{
BS_dt = BS_ex_dt(fc_dt = fc_dt,
fc_col = fc_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
clim_es_dt = BS_ex_dt(fc_dt = fc_dt,
fc_col = clim_col,
threshold_col = threshold_col,
obs_col = obs_col,
by_cols = by_cols)
setnames(clim_es_dt,'BS_ex','clim_BS_ex')
score_dt = merge(BS_dt,clim_es_dt,by = intersect(names(es_dt),names(clim_es_dt)))
score_dt[,BSS_ex := (clim_BS_ex - BS_ex)/clim_BS_ex ]
#deal with divisions by 0:
score_dt[clim_BS_ex == 0 & BS_ex == 0, BSS_ex := 0] # when both are perfect, skill score should be 0
score_dt[clim_BS_ex == 0 & BS_ex > 0, BSS_ex := min(min(BSS_ex,na.rm = T), -1)] # set to something negative (capped at -1), when climatology predicts perfectly and the forecast does not
#(should actually -Inf, but that's bad for plotting).
return(score_dt)
}
bss_dt = BSS_ex_dt(dt,fc_col = 'pexcd',threshold_col = 'rthr',obs_col = 'prec',by_cols = c('model','month','lon','lat'))
plot_list = list()
for(mod in unique(bss_dt[,model]))
{
plot_list = c(plot_list,list(ggplot_dt(bss_dt[model == mod& month == 3 & rthr == 200],'BSS_ex',mn = mod, high = 'red',midpoint = 0,rr= c(-1,1))))
}
ggpubr::ggarrange(plotlist = plot_list,ncol = 3,nrow = 3)
bss_dt
devtools::document()
q()
### This script renders the SeaVal documentation
# It essentially knits all .rmd files in this folder, starting with index.rmd and then following the naming order (so the file names should start with a number)
setwd('~/pkg/SeaVal/scripts/SeaValDocumentation/bookdown/') # adjust to your local repository!
bookdown::render_book('index.rmd',
'bookdown::gitbook',
new_session = T)
# We need to copy paste, the output_dir option of render_book does not work, see https://github.com/rstudio/bookdown/issues/804
output_dir = '/nr/common/www/virtual/files.nr.no/htdocs/samba/CONFER/SeaVal/'# this directory is shared at http://files.nr.no/samba/CONFER/SeaVal/
file.copy(list.files('./_book/',full.names = TRUE), to = output_dir, recursive = TRUE)
obs_dt
dt
library(data.table)
dt
fc_dt = dt
fc_cn = 'prec'
obs_cn = 'obs'
by_cns = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt))
along_cns = c('year')
if(!('year' %in% along_cns)) stop('skill scores are with respect to leave-one-year-out climatology, so your along_cns must contain "year".')
obs_dt = unique(fc_dt[,.SD,.SDcols = intersect(c(obs_cn,by_cns,along_cns),c('year','month','lon','lat',obs_cn))])
obs_by_cns = intersect(by_cns,names(obs_dt))
climatology_prediction = climatology_ens_forecast(obs_dt = obs_dt,
by_cols = obs_by_cols)
climatology_ens_forecast = function(obs_dt,
by_cols)
{
years = unique(obs_dt[,year])
ret_dt = data.table()
for(yy in years)
{
dt_temp = obs_dt[year != yy][,member := 1:.N,by = by_cols][,year:=yy]
ret_dt = rbindlist(list(ret_dt,dt_temp))
}
return(ret_dt)
}
climatology_prediction = climatology_ens_forecast(obs_dt = obs_dt,
by_cols = obs_by_cols)
climatology_prediction = climatology_ens_forecast(obs_dt = obs_dt,
by_cols = obs_by_cns)
climatology_prediction
setnames(climatology_prediction,'obs','clim')
obs_by_cns
obs_dt
climatology_prediction = merge(climatology_prediction,obs_dt,by = c(obs_by_cns,'year'))
climatology_prediction
climatology_CRPS = CRPS_ens_fc(fc_dt = climatology_prediction,
fc_cn = obs_cn,
obs_cn = obs_cn,
by_cns = obs_by_cns)
CRPS_ens_fc = function(fc_dt,fc_cn,
obs_cn = 'obs',
by_cns = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)),
along_cns = c('year'),
check_dimensions = T,
member_cn = 'member')
{
fc_dt = fc_dt[!is.na(get(obs_cn)) & ! is.na(get(fc_cn))]
if(check_dimensions)
{
check = unique(fc_dt[,.SD,.SDcols = c(by_cns,along_cns,member_cn)])[,.N] == fc_dt[,.N]
if(!check) stop('dimension check failed: your data format does not meet the requirements.')
}
#expand for application of crps:
if(!is.null(by_cns))
{
ff = paste0('year + ',obs_cn,' + ',paste(by_cns,collapse = ' + '),' ~ ',member_cn)
} else {
ff = paste0('year + ',obs_cn,'~ ',member_cn)
}
fc_dt_new = dcast(fc_dt,formula = as.formula(ff),fun.aggregate = mean,value.var = fc_cn,na.rm = T)
pred_cols = (length(by_cns) + length(along_cns) + 2) : ncol(fc_dt_new) # that's a bit hacked
pred_mat = as.matrix(fc_dt_new[,pred_cols,with = FALSE])
obs = fc_dt_new[,get(obs_cn)]
crps_vals = crps_sample_na(obs,pred_mat)
ret_dt = fc_dt_new[,.SD,.SDcols = c(along_cns,by_cns)][,CRPS := crps_vals]
ret_dt = ret_dt[,.(CRPS = mean(CRPS)), by = by_cns]
return(ret_dt)
}
CRPSS_ens_fc = function(fc_dt,fc_cn,
obs_cn = 'obs',
by_cns = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)),
along_cns = c('year'),...)
{
if(!('year' %in% along_cns)) stop('skill scores are with respect to leave-one-year-out climatology, so your along_cns must contain "year".')
obs_dt = unique(fc_dt[,.SD,.SDcols = intersect(c(obs_cn,by_cns,along_cns),c('year','month','lon','lat',obs_cn))])
# note that by_cns can contain e.g. different systems, all of which are compared to the same observation, therefore the intersect.
obs_by_cns = intersect(by_cns,names(obs_dt))
climatology_prediction = climatology_ens_forecast(obs_dt = obs_dt,
by_cols = obs_by_cns)
setnames(climatology_prediction,'obs','clim')
climatology_prediction = merge(climatology_prediction,obs_dt,by = c(obs_by_cns,'year'))
climatology_CRPS = CRPS_ens_fc(fc_dt = climatology_prediction,
fc_cn = obs_cn,
obs_cn = obs_cn,
by_cns = obs_by_cns)
setnames(climatology_CRPS,'CRPS','clim_CRPS')
CRPS_dt = CRPS_ens_fc(fc_dt = fc_dt,
fc_cn = fc_cn,
obs_cn = obs_cn,
by_cns = by_cns,
along_cns = along_cns,...)
CRPS_dt = merge(CRPS_dt,climatology_CRPS)
CRPS_dt[,CRPSS := (clim_CRPS - CRPS)/clim_CRPS]
return(CRPS_dt)
}
climatology_CRPS = CRPS_ens_fc(fc_dt = climatology_prediction,
fc_cn = obs_cn,
obs_cn = obs_cn,
by_cns = obs_by_cns)
setnames(climatology_CRPS,'CRPS','clim_CRPS')
crps_sample_na = function (obs, pred)
{
crps_sample_na_single_obs = function(single_obs,vector_pred)
{
vector_pred2 = vector_pred[!(is.na(vector_pred) | is.nan(vector_pred))]
crps = scoringRules::crps_sample(single_obs,vector_pred2)
return(crps)
}
if(length(obs) == 1)
{
crps = crps_sample_na_single_obs(obs,pred)
} else{
crps = sapply(seq_along(obs), function(i) crps_sample_na_single_obs(obs[i], pred[i,]))
}
return(crps)
}
climatology_CRPS = CRPS_ens_fc(fc_dt = climatology_prediction,
fc_cn = obs_cn,
obs_cn = obs_cn,
by_cns = obs_by_cns)
setnames(climatology_CRPS,'CRPS','clim_CRPS')
CRPS_dt = CRPS_ens_fc(fc_dt = fc_dt,
fc_cn = fc_cn,
obs_cn = obs_cn,
by_cns = by_cns,
along_cns = along_cns,...)
CRPS_dt = CRPS_ens_fc(fc_dt = fc_dt,
fc_cn = fc_cn,
obs_cn = obs_cn,
by_cns = by_cns,
along_cns = along_cns)
CRPS_dt = merge(CRPS_dt,climatology_CRPS)
CRPS_dt[,CRPSS := (clim_CRPS - CRPS)/clim_CRPS]
CRPS_dt
climatology_CRPS
climatology_CRPS
climatology_prediction
climatology_CRPS = CRPS_ens_fc(fc_dt = climatology_prediction,
fc_cn = 'clim',
obs_cn = obs_cn,
by_cns = obs_by_cns)
setnames(climatology_CRPS,'CRPS','clim_CRPS')
CRPS_dt = CRPS_ens_fc(fc_dt = fc_dt,
fc_cn = fc_cn,
obs_cn = obs_cn,
by_cns = by_cns,
along_cns = along_cns,...)
CRPS_dt = merge(CRPS_dt,climatology_CRPS)
CRPS_dt[,CRPSS := (clim_CRPS - CRPS)/clim_CRPS]
MSESS_dt = function(fc_dt,fc_col,
obs_col = ifelse(is.null(obs_dt),yes = 'obs',no = fc_col),
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)),
along_cols = c('year'),...)
{
if(!('year' %in% along_cols)) stop('skill scores are with respect to leave-one-year-out climatology, so your along_cns must contain "year".')
obs_dt = unique(fc_dt[,.SD,.SDcols = intersect(c(obs_col,by_cols,along_cols),c('year','month','season','lon','lat',obs_col))])
# note that by_cols can contain e.g. different systems, all of which are compared to the same observation, therefore the intersect.
obs_by_cols = intersect(by_cols,names(obs_dt))
climatology_prediction = climatology_ens_forecast(obs_dt = obs_dt,
by_cols = obs_by_cols)
setnames(climatology_prediction,'obs','clim')
climatology_prediction = merge(climatology_prediction,obs_dt,by = c(obs_by_cols,'year'))
climatology_MSE = MSE_dt(fc_dt = climatology_prediction,
fc_col = 'clim',
obs_col = obs_col,
by_cols = obs_by_cols)
setnames(climatology_MSE,'MSE','clim_MSE')
MSE_dt = MSE_dt(fc_dt = fc_dt,
fc_col = fc_col,
obs_dt = obs_dt,
obs_col = obs_col,
by_cols = by_cols,
along_cols = along_cols,...)
MSE_dt = merge(MSE_dt,climatology_MSE, by = intersect(names(MSE_dt),names(climatology_MSE)))
MSE_dt[,MSESS := (clim_MSE - MSE)/clim_MSE]
return(MSE_dt)
}
dt
MSESS_dt(dt,'prec','obs')
MSE_dt = function(fc_dt,fc_col,
obs_col = ifelse(is.null(obs_dt),yes = 'obs',no = fc_col),
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)),
along_cols = c('year'),
check_dimensions = T,
member_col = intersect('member',colnames(fc_dt)))
{
if(check_dimensions)
{
check = unique(fc_dt[,.SD,.SDcols = c(by_cols,along_cols,member_col)])[,.N] == fc_dt[,.N]
if(!check) stop('Dimension check failed. Probably you have multiple layers per ensemble member and year after grouping.')
}
fc_dt_new = copy(fc_dt)
# get forecast mean (= mean over all ensemble members)
fc_dt_new[,fc_mean := mean(get(fc_col),na.rm = T),by = c(by_cols,along_cols)]
# take mean along all
MSE_dt = fc_dt_new[,.(MSE = mean((fc_mean - get(obs_col))^2,na.rm = T)),by = by_cols]
return(MSE_dt)
}
MSESS_dt(dt,'prec','obs')
MSESS_dt = function(fc_dt,fc_col,
obs_col = 'obs',
by_cols = intersect(c('month','season','lon','lat','system','lead_time'),names(fc_dt)),
along_cols = c('year'),...)
{
if(!('year' %in% along_cols)) stop('skill scores are with respect to leave-one-year-out climatology, so your along_cns must contain "year".')
obs_dt = unique(fc_dt[,.SD,.SDcols = intersect(c(obs_col,by_cols,along_cols),c('year','month','season','lon','lat',obs_col))])
# note that by_cols can contain e.g. different systems, all of which are compared to the same observation, therefore the intersect.
obs_by_cols = intersect(by_cols,names(obs_dt))
climatology_prediction = climatology_ens_forecast(obs_dt = obs_dt,
by_cols = obs_by_cols)
setnames(climatology_prediction,'obs','clim')
climatology_prediction = merge(climatology_prediction,obs_dt,by = c(obs_by_cols,'year'))
climatology_MSE = MSE_dt(fc_dt = climatology_prediction,
fc_col = 'clim',
obs_col = obs_col,
by_cols = obs_by_cols)
setnames(climatology_MSE,'MSE','clim_MSE')
MSE_dt = MSE_dt(fc_dt = fc_dt,
fc_col = fc_col,
obs_col = obs_col,
by_cols = by_cols,
along_cols = along_cols,...)
MSE_dt = merge(MSE_dt,climatology_MSE, by = intersect(names(MSE_dt),names(climatology_MSE)))
MSE_dt[,MSESS := (clim_MSE - MSE)/clim_MSE]
return(MSE_dt)
}
MSESS_dt(dt,'prec','obs')
?guide_colorbar
bss_dt
library(SeaVal)
library(SeaVal)
library(ggpubr)
library(ggplot2)
load(file = '_temp.RData')
print(dt_prexc)
bss_dt = BSS_ex_dt(dt_prexc,fc_col = 'pexcd',threshold_col = 'rthr',obs_col = 'prec',by_cols = c('model','month','lon','lat'))
print(bss_dt)
print(bss_dt)
print(bss_dt[!is.na(BS_ex)])
bss_dt
mean_scores = bss_dt[,mean(BS_ex,na.rm = T),by = .(model,month,rthr)]
mean_scores
bss_dt
# get climatology score as well:
mean_clim_score = bss_dt[model == model[1],.(BS_ex = mean(clim_BS_ex,na.rm = T)),by = .(month,rthr)]
mean_clim_score
mean_clim_score[,model := 'clim']
mean_scores = rbindlist(list(mean_scores,mean_clim_score))
mean_scores
mean_scores = bss_dt[,.(BS_ex = mean(BS_ex,na.rm = T)),by = .(model,month,rthr)]
mean_clim_score[,model := 'clim']
# get climatology score as well:
mean_clim_score = bss_dt[model == model[1],.(BS_ex = mean(clim_BS_ex,na.rm = T)),by = .(month,rthr)]
mean_clim_score[,model := 'clim']
mean_scores = rbindlist(list(mean_scores,mean_clim_score),use.names = TRUE)
mean_scores
print(mean_scores)
pp = ggplot(mean_scores) + geom_line(aes(x = month,y = BS_ex,color = model,linetype = model)) + facet_wrap(~rthr,nrow = 1)
pp
### This script renders the SeaVal documentation
# It essentially knits all .rmd files in this folder, starting with index.rmd and then following the naming order (so the file names should start with a number)
setwd('~/pkg/SeaVal/scripts/SeaValDocumentation/bookdown/') # adjust to your local repository!
bookdown::render_book('index.rmd',
'bookdown::gitbook',
new_session = T)
# We need to copy paste, the output_dir option of render_book does not work, see https://github.com/rstudio/bookdown/issues/804
output_dir = '/nr/common/www/virtual/files.nr.no/htdocs/samba/CONFER/SeaVal/'# this directory is shared at http://files.nr.no/samba/CONFER/SeaVal/
file.copy(list.files('./_book/',full.names = TRUE), to = output_dir, recursive = TRUE)
### This script renders the SeaVal documentation
# It essentially knits all .rmd files in this folder, starting with index.rmd and then following the naming order (so the file names should start with a number)
setwd('~/pkg/SeaVal/scripts/SeaValDocumentation/bookdown/') # adjust to your local repository!
bookdown::render_book('index.rmd',
'bookdown::gitbook',
new_session = T)
# We need to copy paste, the output_dir option of render_book does not work, see https://github.com/rstudio/bookdown/issues/804
output_dir = '/nr/common/www/virtual/files.nr.no/htdocs/samba/CONFER/SeaVal/'# this directory is shared at http://files.nr.no/samba/CONFER/SeaVal/
file.copy(list.files('./_book/',full.names = TRUE), to = output_dir, recursive = TRUE)
### This script renders the SeaVal documentation
# It essentially knits all .rmd files in this folder, starting with index.rmd and then following the naming order (so the file names should start with a number)
setwd('~/pkg/SeaVal/scripts/SeaValDocumentation/bookdown/') # adjust to your local repository!
bookdown::render_book('index.rmd',
'bookdown::gitbook',
new_session = T)
# We need to copy paste, the output_dir option of render_book does not work, see https://github.com/rstudio/bookdown/issues/804
output_dir = '/nr/common/www/virtual/files.nr.no/htdocs/samba/CONFER/SeaVal/'# this directory is shared at http://files.nr.no/samba/CONFER/SeaVal/
file.copy(list.files('./_book/',full.names = TRUE), to = output_dir, recursive = TRUE)
### This script renders the SeaVal documentation
# It essentially knits all .rmd files in this folder, starting with index.rmd and then following the naming order (so the file names should start with a number)
setwd('~/pkg/SeaVal/scripts/SeaValDocumentation/bookdown/') # adjust to your local repository!
bookdown::render_book('index.rmd',
'bookdown::gitbook',
new_session = T)
# We need to copy paste, the output_dir option of render_book does not work, see https://github.com/rstudio/bookdown/issues/804
output_dir = '/nr/common/www/virtual/files.nr.no/htdocs/samba/CONFER/SeaVal/'# this directory is shared at http://files.nr.no/samba/CONFER/SeaVal/
file.copy(list.files('./_book/',full.names = TRUE), to = output_dir, recursive = TRUE)
### This script renders the SeaVal documentation
# It essentially knits all .rmd files in this folder, starting with index.rmd and then following the naming order (so the file names should start with a number)
setwd('~/pkg/SeaVal/scripts/SeaValDocumentation/bookdown/') # adjust to your local repository!
bookdown::render_book('index.rmd',
'bookdown::gitbook',
new_session = T)
# We need to copy paste, the output_dir option of render_book does not work, see https://github.com/rstudio/bookdown/issues/804
output_dir = '/nr/common/www/virtual/files.nr.no/htdocs/samba/CONFER/SeaVal/'# this directory is shared at http://files.nr.no/samba/CONFER/SeaVal/
file.copy(list.files('./_book/',full.names = TRUE), to = output_dir, recursive = TRUE)
countries
unique(countries[[3]])
dt = dt_tercile_forecast
print(dt)
### This script renders the SeaVal documentation
# It essentially knits all .rmd files in this folder, starting with index.rmd and then following the naming order (so the file names should start with a number)
### adjust to your setup: ###
setwd('~/pkg/SeaVal/scripts/SeaValDocumentation/bookdown/')
data_dir = '/nr/project/stat/CONFER/Data/validation/example_data/202102/'
output_dir = '/nr/common/www/virtual/files.nr.no/htdocs/samba/CONFER/SeaVal/'
# this directory is shared at http://files.nr.no/samba/CONFER/SeaVal/
save(data_dir,file = '_data_dir.RData') # just for loading it in the bookdown
bookdown::render_book('index.rmd',
'bookdown::gitbook',
new_session = T)
# We need to copy paste, the output_dir option of render_book does not work, see https://github.com/rstudio/bookdown/issues/804
file.copy(list.files('./_book/',full.names = TRUE), to = output_dir, recursive = TRUE)
### This script renders the SeaVal documentation
# It essentially knits all .rmd files in this folder, starting with index.rmd and then following the naming order (so the file names should start with a number)
### adjust to your setup: ###
setwd('~/pkg/SeaVal/scripts/SeaValDocumentation/bookdown/')
data_dir = '/nr/project/stat/CONFER/Data/validation/example_data/202102/'
output_dir = '/nr/common/www/virtual/files.nr.no/htdocs/samba/CONFER/SeaVal/'
# this directory is shared at http://files.nr.no/samba/CONFER/SeaVal/
save(data_dir,file = '_data_dir.RData') # just for loading it in the bookdown
bookdown::render_book('index.rmd',
'bookdown::gitbook',
new_session = T)
# We need to copy paste, the output_dir option of render_book does not work, see https://github.com/rstudio/bookdown/issues/804
file.copy(list.files('./_book/',full.names = TRUE), to = output_dir, recursive = TRUE)
devtools::document()
q()
